"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[2148],{8469:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>a,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"api-integration-patterns","title":"API Integration Patterns","description":"Learn how to integrate with backend APIs using generated OpenAPI SDKs for type-safe API calls.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/api-integration-patterns.md","sourceDirName":".","slug":"/api-integration-patterns","permalink":"/docs/api-integration-patterns","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"description":"Learn how to integrate with backend APIs using generated OpenAPI SDKs for type-safe API calls."},"sidebar":"tutorialSidebar","previous":{"title":"State Management Patterns","permalink":"/docs/state-management-patterns"},"next":{"title":"Form Handling Patterns","permalink":"/docs/form-handling-patterns"}}');var s=t(4848),i=t(8453);const a={description:"Learn how to integrate with backend APIs using generated OpenAPI SDKs for type-safe API calls."},o="API Integration Patterns",c={},d=[{value:"When to Use This Guide",id:"when-to-use-this-guide",level:2},{value:"Problems This Pattern Solves",id:"problems-this-pattern-solves",level:2},{value:"SDK Generation Setup",id:"sdk-generation-setup",level:2},{value:"Use Case: Generate Type-Safe API Client",id:"use-case-generate-type-safe-api-client",level:3},{value:"Installing Dependencies",id:"installing-dependencies",level:3},{value:"Configuration",id:"configuration",level:3},{value:"Package.json Scripts",id:"packagejson-scripts",level:3},{value:"Generated SDK Structure",id:"generated-sdk-structure",level:2},{value:"Generated Types Example",id:"generated-types-example",level:3},{value:"Generated Services Example",id:"generated-services-example",level:3},{value:"Client Configuration",id:"client-configuration",level:2},{value:"Use Case: Add Authentication to All Requests",id:"use-case-add-authentication-to-all-requests",level:3},{value:"Use Case: Create API Wrapper with Error Handling",id:"use-case-create-api-wrapper-with-error-handling",level:3},{value:"React Query Integration",id:"react-query-integration",level:2},{value:"Use Case: Data Fetching with Caching",id:"use-case-data-fetching-with-caching",level:3},{value:"Use Case: Product List with Filtering",id:"use-case-product-list-with-filtering",level:3},{value:"Error Handling",id:"error-handling",level:2},{value:"Use Case: Structured Error Responses",id:"use-case-structured-error-responses",level:3},{value:"Use Case: Centralized Error Handler",id:"use-case-centralized-error-handler",level:3},{value:"Use Case: Display Errors with Field Details",id:"use-case-display-errors-with-field-details",level:3},{value:"Multi-Tenant API Calls",id:"multi-tenant-api-calls",level:2},{value:"Use Case: Tenant Context for SaaS Applications",id:"use-case-tenant-context-for-saas-applications",level:3},{value:"Use Case: Tenant-Scoped Queries",id:"use-case-tenant-scoped-queries",level:3},{value:"File Upload Integration",id:"file-upload-integration",level:2},{value:"Use Case: Upload Files to S3 via API",id:"use-case-upload-files-to-s3-via-api",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Always Regenerate SDK After Backend Changes",id:"1-always-regenerate-sdk-after-backend-changes",level:3},{value:"2. Use Type Guards",id:"2-use-type-guards",level:3},{value:"3. Handle Loading and Error States",id:"3-handle-loading-and-error-states",level:3},{value:"4. Version Handling for Updates",id:"4-version-handling-for-updates",level:3},{value:"5. Retry Configuration",id:"5-retry-configuration",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"api-integration-patterns",children:"API Integration Patterns"})}),"\n",(0,s.jsx)(n.p,{children:"This guide explains how to connect frontend applications to MBC CQRS Serverless backends using auto-generated TypeScript SDKs. Type-safe API integration catches errors at compile time and provides excellent developer experience with autocomplete."}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-this-guide",children:"When to Use This Guide"}),"\n",(0,s.jsx)(n.p,{children:"Use this guide when you need to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Connect a Next.js frontend to an MBC CQRS Serverless API"}),"\n",(0,s.jsx)(n.li,{children:"Generate TypeScript types from OpenAPI specification"}),"\n",(0,s.jsx)(n.li,{children:"Add authentication headers automatically to API requests"}),"\n",(0,s.jsx)(n.li,{children:"Handle API errors consistently across the application"}),"\n",(0,s.jsx)(n.li,{children:"Support multi-tenant API calls with tenant headers"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"problems-this-pattern-solves",children:"Problems This Pattern Solves"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Problem"}),(0,s.jsx)(n.th,{children:"Solution"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Frontend types don't match backend API"}),(0,s.jsx)(n.td,{children:"Generate SDK from OpenAPI spec - types always match"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Forgetting to add auth token to requests"}),(0,s.jsx)(n.td,{children:"Use interceptors to add headers automatically"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Inconsistent error handling across components"}),(0,s.jsx)(n.td,{children:"Centralize error handling in API wrapper"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Tenant header missing in some requests"}),(0,s.jsx)(n.td,{children:"Add tenant interceptor that reads from store"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Hard to update when API changes"}),(0,s.jsx)(n.td,{children:"Regenerate SDK with one command"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"sdk-generation-setup",children:"SDK Generation Setup"}),"\n",(0,s.jsx)(n.h3,{id:"use-case-generate-type-safe-api-client",children:"Use Case: Generate Type-Safe API Client"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: Backend team updates the API, and you need frontend types to match."}),"\n",(0,s.jsx)(n.p,{children:"Solution: Generate SDK from OpenAPI specification file that backend exports."}),"\n",(0,s.jsx)(n.h3,{id:"installing-dependencies",children:"Installing Dependencies"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"npm install @hey-api/client-fetch\nnpm install -D @hey-api/openapi-ts\n"})}),"\n",(0,s.jsx)(n.h3,{id:"configuration",children:"Configuration"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// openapi-ts.config.ts\nimport { defineConfig } from '@hey-api/openapi-ts';\n\nexport default defineConfig({\n  client: '@hey-api/client-fetch',\n  input: './openapi.json', // or URL to OpenAPI spec\n  output: {\n    path: 'src/services/sdk',\n    format: 'prettier',\n  },\n  services: {\n    asClass: true,\n  },\n  types: {\n    enums: 'javascript',\n  },\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"packagejson-scripts",children:"Package.json Scripts"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    "generate-sdk": "openapi-ts",\n    "generate-sdk:watch": "openapi-ts --watch"\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"generated-sdk-structure",children:"Generated SDK Structure"}),"\n",(0,s.jsxs)(n.p,{children:["After running ",(0,s.jsx)(n.code,{children:"npm run generate-sdk"}),", the following files are created:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"src/services/sdk/\n\u251c\u2500\u2500 client/\n\u2502   \u2514\u2500\u2500 client.ts          # HTTP client configuration\n\u251c\u2500\u2500 types.gen.ts           # Generated TypeScript types\n\u251c\u2500\u2500 services.gen.ts        # Generated service classes\n\u2514\u2500\u2500 index.ts               # Main exports\n"})}),"\n",(0,s.jsx)(n.h3,{id:"generated-types-example",children:"Generated Types Example"}),"\n",(0,s.jsx)(n.p,{children:"These types are generated from your OpenAPI spec and match your backend exactly:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/services/sdk/types.gen.ts (auto-generated)\nexport interface Product {\n  id: string;\n  pk: string;\n  sk: string;\n  code: string;\n  name: string;\n  price: number;\n  status: ProductStatus;\n  attributes: ProductAttributes;\n  version: number;\n  createdAt: string;\n  updatedAt: string;\n}\n\nexport interface CreateProductDto {\n  code: string;\n  name: string;\n  price: number;\n  attributes?: ProductAttributes;\n}\n\nexport interface UpdateProductDto {\n  name?: string;\n  price?: number;\n  status?: ProductStatus;\n  attributes?: ProductAttributes;\n  version: number; // Required for optimistic locking\n}\n\nexport interface ProductListResponse {\n  items: Product[];\n  count: number;\n  hasMore: boolean;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"generated-services-example",children:"Generated Services Example"}),"\n",(0,s.jsx)(n.p,{children:"Service classes provide typed methods for each API endpoint:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/services/sdk/services.gen.ts (auto-generated)\nexport class ProductService {\n  static list(options?: { query?: ProductListParams }): Promise<ProductListResponse>;\n  static get(options: { path: { pk: string; sk: string}}): Promise<Product>;\n  static create(options: { body: CreateProductDto }): Promise<Product>;\n  static update(options: { path: { pk: string; sk: string }; body: UpdateProductDto }): Promise<Product>;\n  static delete(options: { path: { pk: string; sk: string}}): Promise<void>;\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"client-configuration",children:"Client Configuration"}),"\n",(0,s.jsx)(n.h3,{id:"use-case-add-authentication-to-all-requests",children:"Use Case: Add Authentication to All Requests"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: Every API request needs a Bearer token from Cognito."}),"\n",(0,s.jsx)(n.p,{children:"Problem: Manually adding headers to each request is error-prone."}),"\n",(0,s.jsx)(n.p,{children:"Solution: Use interceptors to add authentication header automatically."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/lib/api/client.ts\nimport { client } from '@/services/sdk/client';\nimport { fetchAuthSession } from 'aws-amplify/auth';\n\n// Configure the base URL\nclient.setConfig({\n  baseUrl: process.env.NEXT_PUBLIC_API_URL,\n});\n\n// Add authentication interceptor\nclient.interceptors.request.use(async (request) => {\n  try {\n    const session = await fetchAuthSession();\n    const token = session.tokens?.idToken?.toString();\n\n    if (token) {\n      request.headers.set('Authorization', `Bearer ${token}`);\n    }\n  } catch (error) {\n    console.error('Failed to get auth token:', error);\n  }\n\n  return request;\n});\n\n// Add tenant header interceptor\nclient.interceptors.request.use((request) => {\n  const tenantCode = getTenantFromStore(); // Get from Zustand store\n  if (tenantCode) {\n    request.headers.set('X-Tenant-Code', tenantCode);\n  }\n  return request;\n});\n\n// Add error handling interceptor\nclient.interceptors.response.use((response) => {\n  if (!response.ok) {\n    // Handle specific error codes\n    if (response.status === 401) {\n      // Redirect to login\n      window.location.href = '/login';\n    }\n  }\n  return response;\n});\n\nexport { client };\n"})}),"\n",(0,s.jsx)(n.h3,{id:"use-case-create-api-wrapper-with-error-handling",children:"Use Case: Create API Wrapper with Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: Components need clean APIs that throw meaningful errors."}),"\n",(0,s.jsxs)(n.p,{children:["Problem: Generated SDK returns ",(0,s.jsx)(n.code,{children:"{ data, error }"})," which requires handling in every component."]}),"\n",(0,s.jsx)(n.p,{children:"Solution: Create wrapper functions that throw on errors for use with React Query."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/services/api/products.ts\nimport { ProductService, CreateProductDto, UpdateProductDto } from '@/services/sdk';\nimport type { Product, ProductListResponse } from '@/services/sdk';\n\nexport interface ProductFilters {\n  status?: string;\n  category?: string;\n  search?: string;\n  page?: number;\n  limit?: number;\n}\n\nexport const productApi = {\n  async list(filters: ProductFilters = {}): Promise<ProductListResponse> {\n    const { data, error } = await ProductService.list({\n      query: {\n        status: filters.status,\n        category: filters.category,\n        q: filters.search,\n        page: filters.page ?? 1,\n        limit: filters.limit ?? 20,\n      },\n    });\n\n    if (error) {\n      throw new Error(error.message || 'Failed to fetch products');\n    }\n\n    return data;\n  },\n\n  async get(pk: string, sk: string): Promise<Product> {\n    const { data, error } = await ProductService.get({\n      path: { pk, sk },\n    });\n\n    if (error) {\n      throw new Error(error.message || 'Failed to fetch product');\n    }\n\n    return data;\n  },\n\n  async create(dto: CreateProductDto): Promise<Product> {\n    const { data, error } = await ProductService.create({\n      body: dto,\n    });\n\n    if (error) {\n      throw new Error(error.message || 'Failed to create product');\n    }\n\n    return data;\n  },\n\n  async update(pk: string, sk: string, dto: UpdateProductDto): Promise<Product> {\n    const { data, error } = await ProductService.update({\n      path: { pk, sk },\n      body: dto,\n    });\n\n    if (error) {\n      throw new Error(error.message || 'Failed to update product');\n    }\n\n    return data;\n  },\n\n  async delete(pk: string, sk: string): Promise<void> {\n    const { error } = await ProductService.delete({\n      path: { pk, sk },\n    });\n\n    if (error) {\n      throw new Error(error.message || 'Failed to delete product');\n    }\n  },\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"react-query-integration",children:"React Query Integration"}),"\n",(0,s.jsx)(n.h3,{id:"use-case-data-fetching-with-caching",children:"Use Case: Data Fetching with Caching"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: Display product list and detail pages with efficient caching."}),"\n",(0,s.jsx)(n.p,{children:"Solution: Create React Query hooks that use the API wrapper."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/hooks/useProducts.ts\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';\nimport { productApi, ProductFilters } from '@/services/api/products';\nimport type { CreateProductDto, UpdateProductDto } from '@/services/sdk';\n\nexport const productKeys = {\n  all: ['products'] as const,\n  lists: () => [...productKeys.all, 'list'] as const,\n  list: (filters: ProductFilters) => [...productKeys.lists(), filters] as const,\n  details: () => [...productKeys.all, 'detail'] as const,\n  detail: (pk: string, sk: string) => [...productKeys.details(), pk, sk] as const,\n};\n\nexport function useProducts(filters: ProductFilters = {}) {\n  return useQuery({\n    queryKey: productKeys.list(filters),\n    queryFn: () => productApi.list(filters),\n    staleTime: 60 * 1000, // 1 minute\n  });\n}\n\nexport function useProduct(pk: string, sk: string) {\n  return useQuery({\n    queryKey: productKeys.detail(pk, sk),\n    queryFn: () => productApi.get(pk, sk),\n    enabled: !!pk && !!sk,\n  });\n}\n\nexport function useCreateProduct() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: (dto: CreateProductDto) => productApi.create(dto),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: productKeys.lists() });\n    },\n  });\n}\n\nexport function useUpdateProduct() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ pk, sk, dto }: { pk: string; sk: string; dto: UpdateProductDto }) =>\n      productApi.update(pk, sk, dto),\n    onSuccess: (_, { pk, sk }) => {\n      queryClient.invalidateQueries({ queryKey: productKeys.lists() });\n      queryClient.invalidateQueries({ queryKey: productKeys.detail(pk, sk) });\n    },\n  });\n}\n\nexport function useDeleteProduct() {\n  const queryClient = useQueryClient();\n\n  return useMutation({\n    mutationFn: ({ pk, sk }: { pk: string; sk: string }) =>\n      productApi.delete(pk, sk),\n    onSuccess: () => {\n      queryClient.invalidateQueries({ queryKey: productKeys.lists() });\n    },\n  });\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"use-case-product-list-with-filtering",children:"Use Case: Product List with Filtering"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: Display filterable, paginated product table."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/containers/products/ProductList.tsx\n'use client';\n\nimport { useProducts, useDeleteProduct } from '@/hooks/useProducts';\nimport { Button } from '@/components/ui/Button';\nimport { Table } from '@/components/ui/Table';\nimport { useState } from 'react';\n\nexport function ProductList() {\n  const [filters, setFilters] = useState({ page: 1, limit: 20 });\n  const { data, isLoading, error } = useProducts(filters);\n  const deleteProduct = useDeleteProduct();\n\n  if (isLoading) return <div>Loading...</div>;\n  if (error) return <div>Error: {error.message}</div>;\n\n  const handleDelete = async (pk: string, sk: string) => {\n    if (confirm('Are you sure you want to delete this product?')) {\n      await deleteProduct.mutateAsync({ pk, sk });\n    }\n  };\n\n  return (\n    <Table\n      data={data?.items ?? []}\n      columns={[\n        { key: 'code', header: 'Code' },\n        { key: 'name', header: 'Name' },\n        { key: 'price', header: 'Price' },\n        { key: 'status', header: 'Status' },\n        {\n          key: 'actions',\n          header: 'Actions',\n          render: (row) => (\n            <Button\n              variant=\"danger\"\n              size=\"sm\"\n              onClick={() => handleDelete(row.pk, row.sk)}\n              loading={deleteProduct.isPending}\n            >\n              Delete\n            </Button>\n          ),\n        },\n      ]}\n      pagination={{\n        page: filters.page,\n        limit: filters.limit,\n        total: data?.count ?? 0,\n        onChange: (page) => setFilters((f) => ({ ...f, page })),\n     }}\n    />\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.h3,{id:"use-case-structured-error-responses",children:"Use Case: Structured Error Responses"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: Backend returns structured errors with field-level validation details."}),"\n",(0,s.jsx)(n.p,{children:"Solution: Create error types that match backend response format."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/types/api-errors.ts\nexport interface ApiError {\n  statusCode: number;\n  message: string;\n  error?: string;\n  details?: Record<string, string[]>;\n}\n\nexport class ApiException extends Error {\n  constructor(\n    public statusCode: number,\n    message: string,\n    public details?: Record<string, string[]>\n  ) {\n    super(message);\n    this.name = 'ApiException';\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"use-case-centralized-error-handler",children:"Use Case: Centralized Error Handler"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: Convert various error types to consistent ApiException."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/lib/api/error-handler.ts\nimport { ApiException } from '@/types/api-errors';\n\nexport function handleApiError(error: unknown): never {\n  if (error instanceof ApiException) {\n    throw error;\n  }\n\n  if (error instanceof Error) {\n    throw new ApiException(500, error.message);\n  }\n\n  throw new ApiException(500, 'An unexpected error occurred');\n}\n\n// Usage in API wrapper\nexport const productApi = {\n  async list(filters: ProductFilters = {}): Promise<ProductListResponse> {\n    try {\n      const { data, error } = await ProductService.list({\n        query: filters,\n      });\n\n      if (error) {\n        throw new ApiException(\n          error.statusCode ?? 500,\n          error.message ?? 'Request failed',\n          error.details\n        );\n      }\n\n      return data;\n    } catch (error) {\n      handleApiError(error);\n    }\n  },\n};\n"})}),"\n",(0,s.jsx)(n.h3,{id:"use-case-display-errors-with-field-details",children:"Use Case: Display Errors with Field Details"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: Show validation errors returned by the server."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/components/ApiError.tsx\nimport { ApiException } from '@/types/api-errors';\nimport { Alert } from '@/components/ui/Alert';\n\ninterface ApiErrorProps {\n  error: Error | null;\n}\n\nexport function ApiError({ error }: ApiErrorProps) {\n  if (!error) return null;\n\n  const isApiException = error instanceof ApiException;\n\n  return (\n    <Alert variant=\"error\">\n      <p>{error.message}</p>\n      {isApiException && error.details && (\n        <ul className=\"mt-2 list-disc list-inside\">\n          {Object.entries(error.details).map(([field, messages]) => (\n            <li key={field}>\n              <strong>{field}:</strong> {messages.join(', ')}\n            </li>\n          ))}\n        </ul>\n      )}\n    </Alert>\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"multi-tenant-api-calls",children:"Multi-Tenant API Calls"}),"\n",(0,s.jsx)(n.h3,{id:"use-case-tenant-context-for-saas-applications",children:"Use Case: Tenant Context for SaaS Applications"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: User can switch between tenants, and all API calls should use the selected tenant."}),"\n",(0,s.jsx)(n.p,{children:"Solution: Store tenant in context/store and add to API headers automatically."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/contexts/TenantContext.tsx\n'use client';\n\nimport { createContext, useContext, ReactNode } from 'react';\nimport { useTenantStore } from '@/stores/useTenantStore';\n\ninterface TenantContextValue {\n  tenantCode: string | null;\n  setTenant: (code: string) => void;\n}\n\nconst TenantContext = createContext<TenantContextValue | undefined>(undefined);\n\nexport function TenantProvider({ children }: { children: ReactNode }) {\n  const { currentTenant, setCurrentTenant } = useTenantStore();\n\n  return (\n    <TenantContext.Provider\n      value={{\n        tenantCode: currentTenant?.code ?? null,\n        setTenant: (code) => setCurrentTenant({ code } as Tenant),\n     }}\n    >\n      {children}\n    </TenantContext.Provider>\n  );\n}\n\nexport function useTenant() {\n  const context = useContext(TenantContext);\n  if (!context) {\n    throw new Error('useTenant must be used within TenantProvider');\n  }\n  return context;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"use-case-tenant-scoped-queries",children:"Use Case: Tenant-Scoped Queries"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: Product list should only show products for the current tenant."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/hooks/useTenantProducts.ts\nimport { useQuery } from '@tanstack/react-query';\nimport { useTenant } from '@/contexts/TenantContext';\nimport { productApi } from '@/services/api/products';\n\nexport function useTenantProducts() {\n  const { tenantCode } = useTenant();\n\n  return useQuery({\n    queryKey: ['products', tenantCode],\n    queryFn: () => productApi.list(),\n    enabled: !!tenantCode,\n  });\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"file-upload-integration",children:"File Upload Integration"}),"\n",(0,s.jsx)(n.h3,{id:"use-case-upload-files-to-s3-via-api",children:"Use Case: Upload Files to S3 via API"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: User uploads product images that need to be stored in S3."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/services/api/files.ts\nimport { FileService } from '@/services/sdk';\n\nexport const fileApi = {\n  async upload(file: File, path: string): Promise<{ url: string }> {\n    const formData = new FormData();\n    formData.append('file', file);\n    formData.append('path', path);\n\n    const { data, error } = await FileService.upload({\n      body: formData,\n    });\n\n    if (error) {\n      throw new Error(error.message || 'Upload failed');\n    }\n\n    return data;\n  },\n\n  async getPresignedUrl(key: string): Promise<{ url: string; expiresIn: number }> {\n    const { data, error } = await FileService.getPresignedUrl({\n      query: { key },\n    });\n\n    if (error) {\n      throw new Error(error.message || 'Failed to get presigned URL');\n    }\n\n    return data;\n  },\n};\n"})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-always-regenerate-sdk-after-backend-changes",children:"1. Always Regenerate SDK After Backend Changes"}),"\n",(0,s.jsx)(n.p,{children:"When: Backend team deploys API changes."}),"\n",(0,s.jsx)(n.p,{children:"Why: Ensures frontend types match backend exactly."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-bash",children:"# After backend API changes\nnpm run generate-sdk\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-use-type-guards",children:"2. Use Type Guards"}),"\n",(0,s.jsx)(n.p,{children:"When: Working with unknown data from external sources."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function isProduct(data: unknown): data is Product {\n  return (\n    typeof data === 'object' &&\n    data !== null &&\n    'id' in data &&\n    'pk' in data &&\n    'sk' in data\n  );\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-handle-loading-and-error-states",children:"3. Handle Loading and Error States"}),"\n",(0,s.jsx)(n.p,{children:"When: Displaying data from API queries."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function ProductDetail({ pk, sk }: { pk: string; sk: string }) {\n  const { data, isLoading, error, refetch } = useProduct(pk, sk);\n\n  if (isLoading) {\n    return <Skeleton />;\n  }\n\n  if (error) {\n    return (\n      <ErrorState\n        message={error.message}\n        onRetry={() => refetch()}\n      />\n    );\n  }\n\n  if (!data) {\n    return <NotFound />;\n  }\n\n  return <ProductView product={data} />;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-version-handling-for-updates",children:"4. Version Handling for Updates"}),"\n",(0,s.jsx)(n.p,{children:"When: Updating entities that use optimistic locking."}),"\n",(0,s.jsx)(n.p,{children:"Why: MBC CQRS Serverless uses version field to prevent concurrent update conflicts."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"function useUpdateProductWithVersion() {\n  const queryClient = useQueryClient();\n  const updateProduct = useUpdateProduct();\n\n  return {\n    ...updateProduct,\n    mutateAsync: async ({ pk, sk, dto }: UpdateParams) => {\n      // Get current version from cache\n      const cached = queryClient.getQueryData<Product>(\n        productKeys.detail(pk, sk)\n      );\n\n      if (!cached) {\n        throw new Error('Product not found in cache');\n      }\n\n      return updateProduct.mutateAsync({\n        pk,\n        sk,\n        dto: { ...dto, version: cached.version },\n      });\n    },\n  };\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-retry-configuration",children:"5. Retry Configuration"}),"\n",(0,s.jsx)(n.p,{children:"When: Configuring React Query client."}),"\n",(0,s.jsx)(n.p,{children:"Why: Avoid retrying client errors (4xx) that will always fail."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// src/lib/api/query-client.ts\nimport { QueryClient } from '@tanstack/react-query';\n\nexport const queryClient = new QueryClient({\n  defaultOptions: {\n    queries: {\n      staleTime: 60 * 1000,\n      retry: (failureCount, error) => {\n        // Don't retry on 4xx errors\n        if (error instanceof ApiException && error.statusCode < 500) {\n          return false;\n        }\n        return failureCount < 3;\n      },\n    },\n    mutations: {\n      retry: false, // Don't retry mutations by default\n    },\n  },\n});\n"})})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>o});var r=t(6540);const s={},i=r.createContext(s);function a(e){const n=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),r.createElement(i.Provider,{value:n},e.children)}}}]);