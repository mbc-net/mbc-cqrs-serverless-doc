"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[3201],{393:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>l,frontMatter:()=>i,metadata:()=>a,toc:()=>r});const a=JSON.parse('{"id":"command-service","title":"CommandService","description":"Learn how to use CommandModule and CommandService for publishing and managing commands.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/command-service.md","sourceDirName":".","slug":"/command-service","permalink":"/docs/command-service","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"description":"Learn how to use CommandModule and CommandService for publishing and managing commands."},"sidebar":"tutorialSidebar","previous":{"title":"Modules","permalink":"/docs/api-reference"},"next":{"title":"DataService","permalink":"/docs/data-service"}}');var o=t(4848),s=t(8453);const i={description:"Learn how to use CommandModule and CommandService for publishing and managing commands."},d="CommandService",c={},r=[{value:"Overview",id:"overview",level:2},{value:"CommandModule Configuration",id:"commandmodule-configuration",level:2},{value:"Register Options",id:"register-options",level:3},{value:"Registration Example",id:"registration-example",level:3},{value:"Using CommandService",id:"using-commandservice",level:2},{value:"Methods",id:"methods",level:2},{value:"<em>async</em> <code>publishAsync(input: CommandInputModel, options: ICommandOptions): Promise&lt;CommandModel | null&gt;</code>",id:"publishasync",level:3},{value:"<em>async</em> <code>publishPartialUpdateAsync( input: CommandPartialInputModel, options: ICommandOptions): Promise&lt;CommandModel&gt;</code>",id:"publishpartialupdateasync",level:3},{value:"<em>async</em> <code>publishSync( input: CommandInputModel, options: ICommandOptions): Promise&lt;CommandModel&gt;</code>",id:"async-publishsync-input-commandinputmodel-options-icommandoptions-promisecommandmodel",level:3},{value:"<em>async</em> <code>publishPartialUpdateSync( input: CommandPartialInputModel, options: ICommandOptions): Promise&lt;CommandModel&gt;</code>",id:"async-publishpartialupdatesync-input-commandpartialinputmodel-options-icommandoptions-promisecommandmodel",level:3},{value:'<em>async</em> <code>publish(input: CommandInputModel, options: ICommandOptions): Promise&lt;CommandModel | null&gt;</code> <span class="badge badge--warning">deprecated</span>',id:"async-publishinput-commandinputmodel-options-icommandoptions-promisecommandmodel--null-deprecated",level:3},{value:'<em>async</em> <code>publishPartialUpdate( input: CommandPartialInputModel, options: ICommandOptions): Promise&lt;CommandModel | null&gt;</code> <span class="badge badge--warning">deprecated</span>',id:"async-publishpartialupdate-input-commandpartialinputmodel-options-icommandoptions-promisecommandmodel--null-deprecated",level:3},{value:"<em>async</em> <code>reSyncData(): Promise&lt;void&gt;</code>",id:"async-resyncdata-promisevoid",level:3},{value:"<em>async</em> <code>getItem(key: DetailKey): Promise&lt;CommandModel&gt;</code>",id:"async-getitemkey-detailkey-promisecommandmodel",level:3},{value:"<em>async</em> <code>getLatestItem(key: DetailKey): Promise&lt;CommandModel&gt;</code>",id:"async-getlatestitemkey-detailkey-promisecommandmodel",level:3},{value:"<em>async</em> <code>getNextCommand(currentKey: DetailKey): Promise&lt;CommandModel&gt;</code>",id:"async-getnextcommandcurrentkey-detailkey-promisecommandmodel",level:3},{value:"<em>async</em> <code>updateStatus(key: DetailKey, status: string, notifyId?: string): Promise&lt;void&gt;</code>",id:"async-updatestatuskey-detailkey-status-string-notifyid-string-promisevoid",level:3},{value:"<em>async</em> <code>duplicate(key: DetailKey, options: ICommandOptions): Promise&lt;CommandModel&gt;</code>",id:"async-duplicatekey-detailkey-options-icommandoptions-promisecommandmodel",level:3},{value:"<em>async</em> <code>updateTaskToken(key: DetailKey, token: string): Promise&lt;CommandModel&gt;</code>",id:"updatetasktoken",level:3},{value:"<em>async</em> <code>updateTtl(key: DetailKey): Promise&lt;any | null&gt;</code>",id:"async-updatettlkey-detailkey-promiseany--null",level:3},{value:"<code>dataSyncHandlers</code> (getter): IDataSyncHandler[]",id:"datasynchandlers-getter-idatasynchandler",level:3},{value:"<code>getDataSyncHandler(name: string): IDataSyncHandler | undefined</code>",id:"getdatasynchandlername-string-idatasynchandler--undefined",level:3},{value:"<code>isNotCommandDirty(item: CommandModel, input: CommandInputModel): boolean</code>",id:"isnotcommanddirtyitem-commandmodel-input-commandinputmodel-boolean",level:3},{value:"<code>tableName</code> (getter/setter): string",id:"tablename-gettersetter-string",level:3}];function m(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"commandservice",children:"CommandService"})}),"\n",(0,o.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"CommandService"})," is a core component of the framework that facilitates the management and synchronization of commands. It primarily provides methods for publishing both full commands and partial commands, allowing for their processing either synchronously or asynchronously, thereby enhancing the overall efficiency and flexibility of command handling within the system."]}),"\n",(0,o.jsx)(n.h2,{id:"commandmodule-configuration",children:"CommandModule Configuration"}),"\n",(0,o.jsx)(n.p,{children:(0,o.jsx)(n.img,{alt:"CommandModule structure",src:t(9563).A+"",width:"1477",height:"379"})}),"\n",(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"CommandModule"})," is a dynamic module used to register data sync handlers and provide services associated with a table name. When importing this module, you must provide a specific option for use."]}),"\n",(0,o.jsx)(n.h3,{id:"register-options",children:"Register Options"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Property"}),(0,o.jsx)(n.th,{children:"Description"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"tableName: string"})}),(0,o.jsx)(n.td,{children:"Provide table name"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"skipError?: boolean"})}),(0,o.jsx)(n.td,{children:"Reserved for future use. Not yet implemented."})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"dataSyncHandlers?: Type[]"})}),(0,o.jsx)(n.td,{children:"Register data sync handlers"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:(0,o.jsx)(n.code,{children:"disableDefaultHandler?: boolean"})}),(0,o.jsxs)(n.td,{children:["If set to ",(0,o.jsx)(n.code,{children:"true"}),", disables the default DynamoDB data sync handler"]})]})]})]}),"\n",(0,o.jsx)(n.h3,{id:"registration-example",children:"Registration Example"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-typescript",children:"import { CommandModule } from '@mbc-cqrs-serverless/core';\nimport { Module } from '@nestjs/common';\n\n@Module({\n  imports: [\n    CommandModule.register({\n      tableName: 'cat',\n      dataSyncHandlers: [CatDataSyncRdsHandler],\n    }),\n  ],\n})\nexport class CatModule {}\n"})}),"\n",(0,o.jsxs)(n.p,{children:["Here, the ",(0,o.jsx)(n.code,{children:"CommandModule"})," registers with the ",(0,o.jsx)(n.code,{children:"cat"})," table name and provides the ",(0,o.jsx)(n.code,{children:"CatDataSyncRdsHandler"})," to the data sync handlers."]}),"\n",(0,o.jsx)(n.h2,{id:"using-commandservice",children:"Using CommandService"}),"\n",(0,o.jsxs)(n.p,{children:["In the example for the method below, assume you import the ",(0,o.jsx)(n.code,{children:"CommandModule"})," into your module as follows:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { CommandModule } from "@mbc-cqrs-serverless/core";\nimport { Module } from "@nestjs/common";\n\nimport { CatDataSyncRdsHandler } from "./handler/cat-rds.handler";\nimport { CatController } from "./cat.controller";\nimport { CatService } from "./cat.service";\n\n@Module({\n  imports: [\n    CommandModule.register({\n      tableName: "cat",\n      dataSyncHandlers: [CatDataSyncRdsHandler],\n    }),\n  ],\n  controllers: [CatController],\n  providers: [CatService],\n})\nexport class CatModule {}\n'})}),"\n",(0,o.jsxs)(n.p,{children:["Then, the ",(0,o.jsx)(n.code,{children:"CommandService"})," and ",(0,o.jsx)(n.code,{children:"DataService"})," will be ready for injection into other services for your use."]}),"\n",(0,o.jsx)(n.admonition,{title:"For Implementation Patterns",type:"tip",children:(0,o.jsxs)(n.p,{children:["For complete CRUD implementation patterns using CommandService, see ",(0,o.jsx)(n.a,{href:"/docs/service-patterns",children:"Service Patterns"}),"."]})}),"\n",(0,o.jsx)(n.h2,{id:"methods",children:"Methods"}),"\n",(0,o.jsxs)(n.h3,{id:"publishasync",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"publishAsync(input: CommandInputModel, options: ICommandOptions): Promise<CommandModel | null>"})]}),"\n",(0,o.jsxs)(n.p,{children:["Utilize this method to publish a full command, as it will insert the command data into the ",(0,o.jsx)(n.strong,{children:"command"})," table."]}),"\n",(0,o.jsx)(n.p,{children:"The method provides immediate feedback by returning the command data right away, allowing you to proceed without waiting for the command to be processed. Subsequently, the command is handled asynchronously in the background, ensuring that your application remains responsive while the processing occurs."}),"\n",(0,o.jsxs)(n.p,{children:[(0,o.jsx)(n.strong,{children:"Return Value:"})," Returns ",(0,o.jsx)(n.code,{children:"Promise<CommandModel>"})," on success, or ",(0,o.jsx)(n.code,{children:"Promise<null>"})," when the command is not dirty (no changes detected compared to the existing command)."]}),"\n",(0,o.jsx)(n.p,{children:"For example, you can publish a new cat command as bellow:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import {\n  generateId,\n  getCommandSource,\n  VERSION_FIRST,\n} from "@mbc-cqrs-serverless/core";\n\n// class CatCommandDto extends CommandDto {}\n\nconst catCommand = new CatCommandDto({\n  pk: catPk,\n  sk: catSk,\n  tenantCode,\n  id: generateId(catPk, catSk),\n  code,\n  type: "CAT",\n  name: attributes.name,\n  version: VERSION_FIRST,\n  attributes,\n});\n\nconst commandSource = getCommandSource(\n  basename(__dirname),\n  this.constructor.name,\n  "createCatCommand"\n);\n\nconst item = await this.commandService.publishAsync(catCommand, {\n  source: commandSource,\n  invokeContext,\n});\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"publishpartialupdateasync",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"publishPartialUpdateAsync( input: CommandPartialInputModel, options: ICommandOptions): Promise<CommandModel>"})]}),"\n",(0,o.jsxs)(n.p,{children:["This method allows you to create new command data based on the previous command with the same ",(0,o.jsx)(n.code,{children:"pk"})," and ",(0,o.jsx)(n.code,{children:"sk"})," (primary key) values."]}),"\n",(0,o.jsxs)(n.p,{children:["As same as the ",(0,o.jsx)(n.code,{children:"publishAsync"})," method, the method immediately returns the updated command data without waiting for the command to be processed."]}),"\n",(0,o.jsx)(n.p,{children:"For example, you want to update cat's name:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { generateId, getCommandSource } from "@mbc-cqrs-serverless/core";\n\n// ...\n\nconst catCommand: CommandPartialInputModel = {\n  pk: catPk,\n  sk: catSk,\n  version: storedItem.version,\n  name: attributes.name,\n};\n\nconst commandSource = getCommandSource(\n  basename(__dirname),\n  this.constructor.name,\n  "updateCatCommand"\n);\n\nconst item = await this.commandService.publishPartialUpdateAsync(catCommand, {\n  source: commandSource,\n  invokeContext,\n});\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"async-publishsync-input-commandinputmodel-options-icommandoptions-promisecommandmodel",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"publishSync( input: CommandInputModel, options: ICommandOptions): Promise<CommandModel>"})]}),"\n",(0,o.jsxs)(n.p,{children:["This method serves as a synchronous counterpart to the ",(0,o.jsx)(n.code,{children:"publishAsync"})," method, meaning that it will halt the execution of the code until the command has been fully processed. This ensures that you receive the result of the command before proceeding with any further operations in your code."]}),"\n",(0,o.jsx)(n.p,{children:"For example:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import {\n  generateId,\n  getCommandSource,\n  VERSION_FIRST,\n} from "@mbc-cqrs-serverless/core";\n\n// class CatCommandDto extends CommandDto {}\n\nconst catCommand = new CatCommandDto({\n  pk: catPk,\n  sk: catSk,\n  tenantCode,\n  id: generateId(catPk, catSk),\n  code,\n  type: "CAT",\n  name: attributes.name,\n  version: VERSION_FIRST,\n  attributes,\n});\n\nconst commandSource = getCommandSource(\n  basename(__dirname),\n  this.constructor.name,\n  "createCatCommandSync"\n);\n\nconst item = await this.commandService.publishSync(catCommand, {\n  source: commandSource,\n  invokeContext,\n});\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"async-publishpartialupdatesync-input-commandpartialinputmodel-options-icommandoptions-promisecommandmodel",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"publishPartialUpdateSync( input: CommandPartialInputModel, options: ICommandOptions): Promise<CommandModel>"})]}),"\n",(0,o.jsxs)(n.p,{children:["This method is a synchronous version of the ",(0,o.jsx)(n.code,{children:"publishPartialUpdateAsync"})," method. It will block the execution of the code until the command is processed."]}),"\n",(0,o.jsx)(n.admonition,{title:"Version Matching",type:"warning",children:(0,o.jsxs)(n.p,{children:["This method requires the ",(0,o.jsx)(n.code,{children:"version"})," field in the input to match the current version of the existing item. If the item is not found or the version does not match, a ",(0,o.jsx)(n.code,{children:"BadRequestException"}),' is thrown with the message "The input is not a valid, item not found or version not match".']})}),"\n",(0,o.jsx)(n.p,{children:"For example, you want to update cat's name:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { generateId, getCommandSource } from "@mbc-cqrs-serverless/core";\n\n// ...\n\nconst catCommand: CommandPartialInputModel = {\n  pk: catPk,\n  sk: catSk,\n  version: storedItem.version,\n  name: attributes.name,\n};\n\nconst commandSource = getCommandSource(\n  basename(__dirname),\n  this.constructor.name,\n  "updateCatCommandSync"\n);\n\nconst item = await this.commandService.publishPartialUpdateSync(catCommand, {\n  source: commandSource,\n  invokeContext,\n});\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"async-publishinput-commandinputmodel-options-icommandoptions-promisecommandmodel--null-deprecated",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"publish(input: CommandInputModel, options: ICommandOptions): Promise<CommandModel | null>"})," ",(0,o.jsx)("span",{class:"badge badge--warning",children:"deprecated"})]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Deprecated, for removal: This API element is subject to removal in a future version. Use ",(0,o.jsxs)(n.a,{href:"#publishasync",children:[(0,o.jsx)(n.code,{children:"publishAsync"})," method"]})," instead."]})}),"\n",(0,o.jsx)(n.p,{children:"For example, you can publish a new cat command as bellow:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import {\n  generateId,\n  getCommandSource,\n  VERSION_FIRST,\n} from "@mbc-cqrs-serverless/core";\n\n// class CatCommandDto extends CommandDto {}\n\nconst catCommand = new CatCommandDto({\n  pk: catPk,\n  sk: catSk,\n  tenantCode,\n  id: generateId(catPk, catSk),\n  code,\n  type: "CAT",\n  name: attributes.name,\n  version: VERSION_FIRST,\n  attributes,\n});\n\nconst commandSource = getCommandSource(\n  basename(__dirname),\n  this.constructor.name,\n  "createCatCommand"\n);\n\nconst item = await this.commandService.publish(catCommand, {\n  source: commandSource,\n  invokeContext,\n});\n'})}),"\n",(0,o.jsx)(n.p,{children:"The method returns the command data."}),"\n",(0,o.jsxs)(n.h3,{id:"async-publishpartialupdate-input-commandpartialinputmodel-options-icommandoptions-promisecommandmodel--null-deprecated",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"publishPartialUpdate( input: CommandPartialInputModel, options: ICommandOptions): Promise<CommandModel | null>"})," ",(0,o.jsx)("span",{class:"badge badge--warning",children:"deprecated"})]}),"\n",(0,o.jsx)(n.admonition,{type:"info",children:(0,o.jsxs)(n.p,{children:["Deprecated, for removal: This API element is subject to removal in a future version. Use ",(0,o.jsxs)(n.a,{href:"#publishpartialupdateasync",children:[(0,o.jsx)(n.code,{children:"publishPartialUpdateAsync"})," method"]})," instead."]})}),"\n",(0,o.jsx)(n.p,{children:"This method allows you to create new command data based on the previous command."}),"\n",(0,o.jsx)(n.p,{children:"For example, you want to update cat's name:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { generateId, getCommandSource } from "@mbc-cqrs-serverless/core";\n\n// ...\n\nconst catCommand: CommandPartialInputModel = {\n  pk: catPk,\n  sk: catSk,\n  version: storedItem.version,\n  name: attributes.name,\n};\n\nconst commandSource = getCommandSource(\n  basename(__dirname),\n  this.constructor.name,\n  "updateCatCommand"\n);\n\nconst item = await this.commandService.publishPartialUpdate(catCommand, {\n  source: commandSource,\n  invokeContext,\n});\n'})}),"\n",(0,o.jsx)(n.p,{children:"The method returns the updated command data."}),"\n",(0,o.jsxs)(n.h3,{id:"async-resyncdata-promisevoid",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"reSyncData(): Promise<void>"})]}),"\n",(0,o.jsx)(n.p,{children:"If you want to reapply the data sync handler, this method is designed for you to use. You only need to call the function as follows:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"await this.commandService.reSyncData();\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"async-getitemkey-detailkey-promisecommandmodel",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"getItem(key: DetailKey): Promise<CommandModel>"})]}),"\n",(0,o.jsxs)(n.p,{children:["Retrieves a command item by its primary key. If the sort key does not include a version separator, it automatically calls ",(0,o.jsx)(n.code,{children:"getLatestItem"})," to get the latest version."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { DetailKey } from "@mbc-cqrs-serverless/core";\n\n// Get a specific version of a command\nconst command = await this.commandService.getItem({\n  pk: "CAT#tenant1",\n  sk: "CAT#cat001@2", // Includes version number\n});\n\n// If no version in sk, automatically gets latest version\nconst latestCommand = await this.commandService.getItem({\n  pk: "CAT#tenant1",\n  sk: "CAT#cat001",\n});\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"async-getlatestitemkey-detailkey-promisecommandmodel",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"getLatestItem(key: DetailKey): Promise<CommandModel>"})]}),"\n",(0,o.jsx)(n.p,{children:"Retrieves the latest version of a command item by its primary key. This method uses a lookup algorithm that starts from the data table's version and searches up/down to find the most recent command version."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { DetailKey } from "@mbc-cqrs-serverless/core";\n\nconst latestCommand = await this.commandService.getLatestItem({\n  pk: "CAT#tenant1",\n  sk: "CAT#cat001", // Sort key without version\n});\n\nif (latestCommand) {\n  console.log(`Latest version: ${latestCommand.version}`);\n}\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"async-getnextcommandcurrentkey-detailkey-promisecommandmodel",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"getNextCommand(currentKey: DetailKey): Promise<CommandModel>"})]}),"\n",(0,o.jsx)(n.p,{children:"Retrieves the next version of a command based on the current command's key. This is useful for processing command chains or implementing retry logic."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { DetailKey } from "@mbc-cqrs-serverless/core";\n\nconst currentKey: DetailKey = {\n  pk: "CAT#tenant1",\n  sk: "CAT#cat001@2",\n};\n\nconst nextCommand = await this.commandService.getNextCommand(currentKey);\n// Returns command with sk: "CAT#cat001@3" if exists\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"async-updatestatuskey-detailkey-status-string-notifyid-string-promisevoid",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"updateStatus(key: DetailKey, status: string, notifyId?: string): Promise<void>"})]}),"\n",(0,o.jsx)(n.p,{children:"Updates the status of a command and sends an SNS notification. This is commonly used to update task or process statuses and notify subscribers of the change."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { DetailKey } from "@mbc-cqrs-serverless/core";\n\nconst key: DetailKey = {\n  pk: "CAT#tenant1",\n  sk: "CAT#cat001@1",\n};\n\n// Update status and send SNS notification\nawait this.commandService.updateStatus(key, "COMPLETED");\n\n// With custom notification ID\nawait this.commandService.updateStatus(key, "FAILED", "custom-notify-id");\n'})}),"\n",(0,o.jsx)(n.p,{children:"The SNS notification payload includes:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"action"}),": ",(0,o.jsx)(n.code,{children:'"command-status"'})]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"pk"}),", ",(0,o.jsx)(n.code,{children:"sk"}),": The command key"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"table"}),": The command table name"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"id"}),": Notification ID (custom or auto-generated)"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"tenantCode"}),": Extracted from pk"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.code,{children:"content"}),": Object containing ",(0,o.jsx)(n.code,{children:"status"})," and ",(0,o.jsx)(n.code,{children:"source"})]}),"\n"]}),"\n",(0,o.jsxs)(n.h3,{id:"async-duplicatekey-detailkey-options-icommandoptions-promisecommandmodel",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"duplicate(key: DetailKey, options: ICommandOptions): Promise<CommandModel>"})]}),"\n",(0,o.jsxs)(n.p,{children:["Creates a duplicate of an existing command with an incremented version number. The duplicated command will have ",(0,o.jsx)(n.code,{children:"source"})," set to ",(0,o.jsx)(n.code,{children:'"duplicated"'})," and updated metadata (timestamp, user, IP)."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { DetailKey, getCommandSource } from "@mbc-cqrs-serverless/core";\nimport { basename } from "path";\n\nconst key: DetailKey = {\n  pk: "CAT#tenant1",\n  sk: "CAT#cat001@1",\n};\n\nconst commandSource = getCommandSource(\n  basename(__dirname),\n  this.constructor.name,\n  "duplicateCatCommand"\n);\n\nconst duplicatedCommand = await this.commandService.duplicate(key, {\n  source: commandSource,\n  invokeContext,\n});\n\n// The duplicated command has:\n// - version incremented by 1\n// - source set to "duplicated"\n// - updated timestamps and user info\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"updatetasktoken",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"updateTaskToken(key: DetailKey, token: string): Promise<CommandModel>"})]}),"\n",(0,o.jsx)(n.p,{children:"Stores an AWS Step Functions task token on a command item. This is used when integrating with Step Functions to enable callback patterns."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { DetailKey } from "@mbc-cqrs-serverless/core";\n\nconst key: DetailKey = {\n  pk: "CAT#tenant1",\n  sk: "CAT#cat001@1",\n};\n\n// Store the Step Functions task token\nawait this.commandService.updateTaskToken(key, event.taskToken);\n\n// Later, use the token to send task success/failure\n// via SendTaskSuccessCommand or SendTaskFailureCommand\n'})}),"\n",(0,o.jsxs)(n.h3,{id:"async-updatettlkey-detailkey-promiseany--null",children:[(0,o.jsx)(n.em,{children:"async"})," ",(0,o.jsx)(n.code,{children:"updateTtl(key: DetailKey): Promise<any | null>"})]}),"\n",(0,o.jsxs)(n.p,{children:["Updates the TTL (Time To Live) of the previous version of a command. This is typically used internally to manage command history retention. Returns ",(0,o.jsx)(n.code,{children:"null"})," if the version is too low or the previous command doesn't exist."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import { DetailKey } from "@mbc-cqrs-serverless/core";\n\nconst key: DetailKey = {\n  pk: "CAT#tenant1",\n  sk: "CAT#cat001@3", // Version 3\n};\n\n// Updates TTL of version 2 (previous version)\nconst result = await this.commandService.updateTtl(key);\n'})}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsx)(n.p,{children:"This method is primarily used internally by the framework for command history management. Direct usage is rarely needed in application code."})}),"\n",(0,o.jsxs)(n.h3,{id:"datasynchandlers-getter-idatasynchandler",children:[(0,o.jsx)(n.code,{children:"dataSyncHandlers"})," (getter): IDataSyncHandler[]"]}),"\n",(0,o.jsx)(n.p,{children:"Returns the array of registered data sync handlers for this CommandService instance. This is useful when you need to inspect or iterate over the handlers programmatically."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// Get all registered data sync handlers\nconst handlers = this.commandService.dataSyncHandlers;\n\nhandlers.forEach((handler) => {\n  console.log(`Handler: ${handler.constructor.name}, Type: ${handler.type}`);\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"getdatasynchandlername-string-idatasynchandler--undefined",children:(0,o.jsx)(n.code,{children:"getDataSyncHandler(name: string): IDataSyncHandler | undefined"})}),"\n",(0,o.jsxs)(n.p,{children:["Retrieves a specific data sync handler by its class name. Returns ",(0,o.jsx)(n.code,{children:"undefined"})," if no handler with the specified name is found."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// Get a specific handler by name\nconst rdsHandler = this.commandService.getDataSyncHandler('CatDataSyncRdsHandler');\n\nif (rdsHandler) {\n  // Use the handler directly\n  await rdsHandler.up(commandModel);\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"isnotcommanddirtyitem-commandmodel-input-commandinputmodel-boolean",children:(0,o.jsx)(n.code,{children:"isNotCommandDirty(item: CommandModel, input: CommandInputModel): boolean"})}),"\n",(0,o.jsxs)(n.p,{children:["Compares an existing command item with a new input to determine if there are any actual changes. Returns ",(0,o.jsx)(n.code,{children:"true"})," if the command is NOT dirty (no changes), returns ",(0,o.jsx)(n.code,{children:"false"})," if there ARE changes."]}),"\n",(0,o.jsx)(n.p,{children:"This method is used internally by publish methods to skip unnecessary writes when no changes are detected. You can also use it directly to check if an update would result in any changes before calling publish."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// Check if an update would result in changes\nconst existingCommand = await this.commandService.getItem({ pk, sk });\n\nif (existingCommand && this.commandService.isNotCommandDirty(existingCommand, newInput)) {\n  // No changes detected, skip the update\n  console.log('Command has no changes, skipping update');\n  return existingCommand;\n}\n\n// Proceed with the update\nconst result = await this.commandService.publishAsync(newInput, options);\n"})}),"\n",(0,o.jsxs)(n.h3,{id:"tablename-gettersetter-string",children:[(0,o.jsx)(n.code,{children:"tableName"})," (getter/setter): string"]}),"\n",(0,o.jsxs)(n.p,{children:["Gets or sets the DynamoDB table name for this CommandService instance. The table name is configured when registering the ",(0,o.jsx)(n.code,{children:"CommandModule"}),", but can be changed at runtime if needed."]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// Get the current table name\nconst currentTable = this.commandService.tableName;\nconsole.log(`Operating on table: ${currentTable}`);\n\n// Set a different table name\nthis.commandService.tableName = 'another-table';\n"})}),"\n",(0,o.jsx)(n.admonition,{type:"note",children:(0,o.jsxs)(n.p,{children:["Changing the table name at runtime is an advanced use case. In most applications, you should configure the table name through ",(0,o.jsx)(n.code,{children:"CommandModule.register()"})," and not change it afterwards."]})})]})}function l(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(m,{...e})}):m(e)}},9563:(e,n,t)=>{t.d(n,{A:()=>a});const a=t.p+"assets/images/CommandModule-6794cea659ee358d3f3283eb83c53e78.png"},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>d});var a=t(6540);const o={},s=a.createContext(o);function i(e){const n=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:n},e.children)}}}]);