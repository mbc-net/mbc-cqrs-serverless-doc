"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[4286],{5366:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>i,default:()=>v,frontMatter:()=>o,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"event-handling-patterns","title":"Event Handling Patterns","description":"Learn patterns for handling events from S3, Step Functions, SQS, and DynamoDB streams in MBC CQRS Serverless.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/event-handling-patterns.md","sourceDirName":".","slug":"/event-handling-patterns","permalink":"/docs/event-handling-patterns","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":18,"frontMatter":{"sidebar_position":18,"description":"Learn patterns for handling events from S3, Step Functions, SQS, and DynamoDB streams in MBC CQRS Serverless."},"sidebar":"tutorialSidebar","previous":{"title":"Modules","permalink":"/docs/modules"},"next":{"title":"Data Sync Handler Examples","permalink":"/docs/data-sync-handler-examples"}}');var s=t(4848),a=t(8453);const o={sidebar_position:18,description:"Learn patterns for handling events from S3, Step Functions, SQS, and DynamoDB streams in MBC CQRS Serverless."},i="Event Handling Patterns",c={},d=[{value:"When to Use This Guide",id:"when-to-use-this-guide",level:2},{value:"Event Architecture Overview",id:"event-architecture-overview",level:2},{value:"Event Factory",id:"event-factory",level:2},{value:"Custom Event Factory",id:"custom-event-factory",level:3},{value:"Register Event Factory",id:"register-event-factory",level:3},{value:"Event Handler Patterns",id:"event-handler-patterns",level:2},{value:"Basic Event Handler",id:"basic-event-handler",level:3},{value:"Step Function Event Handler",id:"step-function-event-handler",level:3},{value:"S3 Event Handler",id:"s3-event-handler",level:3},{value:"SQS Event Handler",id:"sqs-event-handler",level:3},{value:"DynamoDB Stream Handler",id:"dynamodb-stream-handler",level:2},{value:"Data Change Event Handler",id:"data-change-event-handler",level:3},{value:"Error Handling and Retry",id:"error-handling-and-retry",level:2},{value:"Retry Pattern Example",id:"retry-pattern-example",level:3},{value:"AWS Native Retry Options",id:"aws-native-retry-options",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Idempotent Event Handlers",id:"1-idempotent-event-handlers",level:3},{value:"2. Structured Logging",id:"2-structured-logging",level:3},{value:"3. Timeout Handling",id:"3-timeout-handling",level:3},{value:"4. Graceful Degradation",id:"4-graceful-degradation",level:3},{value:"Data Sync Handler",id:"data-sync-handler",level:2},{value:"IDataSyncHandler Interface",id:"idatasynchandler-interface",level:3},{value:"Register Data Sync Handler",id:"register-data-sync-handler",level:3},{value:"Multiple Sync Handlers",id:"multiple-sync-handlers",level:3},{value:"Creating Custom Events",id:"creating-custom-events",level:2},{value:"Custom S3 Event Example",id:"custom-s3-event-example",level:3},{value:"Event Factory Transform Methods",id:"event-factory-transform-methods",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"event-handling-patterns",children:"Event Handling Patterns"})}),"\n",(0,s.jsx)(n.p,{children:"This guide covers patterns for implementing event-driven architectures using various AWS event sources including S3, Step Functions, SQS, and DynamoDB streams."}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-this-guide",children:"When to Use This Guide"}),"\n",(0,s.jsx)(n.p,{children:"Use this guide when you need to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Process file uploads from S3"}),"\n",(0,s.jsx)(n.li,{children:"Orchestrate workflows with Step Functions"}),"\n",(0,s.jsx)(n.li,{children:"Handle asynchronous messages from SQS"}),"\n",(0,s.jsx)(n.li,{children:"React to data changes via DynamoDB streams"}),"\n",(0,s.jsx)(n.li,{children:"Implement error handling and retry logic"}),"\n",(0,s.jsx)(n.li,{children:"Send notifications and alarms"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"event-architecture-overview",children:"Event Architecture Overview"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     S3      \u2502\u2500\u2500\u2500\u2500>\u2502             \u2502     \u2502   Event     \u2502\n\u2502   Events    \u2502     \u2502             \u2502\u2500\u2500\u2500\u2500>\u2502  Handler 1  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502             \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502    Event    \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502    Step     \u2502\u2500\u2500\u2500\u2500>\u2502   Factory   \u2502\u2500\u2500\u2500\u2500>\u2502   Event     \u2502\n\u2502  Functions  \u2502     \u2502             \u2502     \u2502  Handler 2  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2502             \u2502     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n                    \u2502             \u2502\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510     \u2502             \u2502     \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n\u2502     SQS     \u2502\u2500\u2500\u2500\u2500>\u2502             \u2502\u2500\u2500\u2500\u2500>\u2502   Event     \u2502\n\u2502   Events    \u2502     \u2502             \u2502     \u2502  Handler 3  \u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,s.jsx)(n.h2,{id:"event-factory",children:"Event Factory"}),"\n",(0,s.jsx)(n.h3,{id:"custom-event-factory",children:"Custom Event Factory"}),"\n",(0,s.jsx)(n.p,{children:"The Event Factory routes incoming events to appropriate handlers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// event-factory.ts\nimport { Injectable } from '@nestjs/common';\nimport {\n  EventFactory,\n  DefaultEventFactory,\n  IEvent,\n} from '@mbc-cqrs-serverless/core';\nimport { S3Event } from 'aws-lambda';\nimport { StepFunctionsEvent, SQSEvent, DynamoDBStreamEvent } from './types';\n\n// Import event classes\nimport { CsvImportEvent } from './csv-import/event/csv-import.event';\nimport { FileProcessEvent } from './file/event/file-process.event';\nimport { OrderCreatedEvent } from './order/event/order-created.event';\nimport { SendNotificationEvent } from './notification/event/send-notification.event';\n\n@EventFactory()\n@Injectable()\nexport class CustomEventFactory extends DefaultEventFactory {\n  /**\n   * Transform S3 events to domain events\n   */\n  async transformS3(event: S3Event): Promise<IEvent[]> {\n    const events: IEvent[] = [];\n\n    for (const record of event.Records) {\n      const bucket = record.s3.bucket.name;\n      const key = decodeURIComponent(record.s3.object.key.replace(/\\+/g, ' '));\n\n      // Route based on S3 key pattern\n      if (key.startsWith('imports/csv/')) {\n        events.push(new CsvImportEvent({\n          bucket,\n          key,\n          eventType: record.eventName,\n          size: record.s3.object.size,\n        }));\n      } else if (key.startsWith('uploads/')) {\n        events.push(new FileProcessEvent({\n          bucket,\n          key,\n          eventType: record.eventName,\n        }));\n      }\n    }\n\n    return events;\n  }\n\n  /**\n   * Transform Step Functions events to domain events\n   */\n  async transformStepFunction(event: StepFunctionsEvent): Promise<IEvent[]> {\n    const { type, payload, taskToken } = event;\n\n    switch (type) {\n      case 'CSV_IMPORT':\n        return [new CsvImportEvent({\n          ...payload,\n          taskToken,\n        })];\n\n      case 'ORDER_PROCESS':\n        return [new OrderCreatedEvent({\n          ...payload,\n          taskToken,\n        })];\n\n      default:\n        console.warn(`Unknown Step Function event type: ${type}`);\n        return [];\n    }\n  }\n\n  /**\n   * Transform SQS events to domain events\n   */\n  async transformSqs(event: SQSEvent): Promise<IEvent[]> {\n    const events: IEvent[] = [];\n\n    for (const record of event.Records) {\n      const body = JSON.parse(record.body);\n\n      switch (body.type) {\n        case 'SEND_NOTIFICATION':\n          events.push(new SendNotificationEvent(body));\n          break;\n        // Add more event types as needed\n      }\n    }\n\n    return events;\n  }\n\n  /**\n   * Transform DynamoDB stream events to domain events\n   */\n  async transformDynamodbStream(event: DynamoDBStreamEvent): Promise<IEvent[]> {\n    const events: IEvent[] = [];\n\n    for (const record of event.Records) {\n      if (record.eventName === 'INSERT' || record.eventName === 'MODIFY') {\n        const newImage = record.dynamodb?.NewImage;\n        if (newImage) {\n          // Route based on entity type\n          const pk = newImage.pk?.S || '';\n          if (pk.startsWith('ORDER#')) {\n            events.push(new OrderCreatedEvent({\n              pk,\n              sk: newImage.sk?.S,\n              data: newImage,\n            }));\n          }\n        }\n      }\n    }\n\n    return events;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"register-event-factory",children:"Register Event Factory"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// main.module.ts\nimport { Module } from '@nestjs/common';\nimport { CustomEventFactory } from './event-factory';\n\n@Module({\n  providers: [CustomEventFactory],\n  // ... other configuration\n})\nexport class MainModule {}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"event-handler-patterns",children:"Event Handler Patterns"}),"\n",(0,s.jsx)(n.h3,{id:"basic-event-handler",children:"Basic Event Handler"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// order/event/order-created.event.ts\nexport class OrderCreatedEvent {\n  pk: string;\n  sk: string;\n  orderId: string;\n  tenantCode: string;\n  taskToken?: string;\n\n  constructor(data: Partial<OrderCreatedEvent>) {\n    Object.assign(this, data);\n  }\n}\n\n// order/event/order-created.handler.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { EventHandler, IEventHandler } from '@mbc-cqrs-serverless/core';\nimport { OrderCreatedEvent } from './order-created.event';\nimport { NotificationService } from '../../notification/notification.service';\nimport { InventoryService } from '../../inventory/inventory.service';\n\ninterface OrderProcessingResult {\n  success: boolean;\n  orderId: string;\n}\n\n@EventHandler(OrderCreatedEvent)\n@Injectable()\nexport class OrderCreatedHandler implements IEventHandler<OrderCreatedEvent, OrderProcessingResult> {\n  private readonly logger = new Logger(OrderCreatedHandler.name);\n\n  constructor(\n    private readonly notificationService: NotificationService,\n    private readonly inventoryService: InventoryService,\n  ) {}\n\n  /**\n   * Handle order created event\n   */\n  async execute(event: OrderCreatedEvent): Promise<OrderProcessingResult> {\n    this.logger.log(`Processing order: ${event.orderId}`);\n\n    try {\n      // Process order-related tasks\n      await Promise.all([\n        this.updateInventory(event),\n        this.sendNotification(event),\n        this.triggerWorkflow(event),\n      ]);\n\n      return {\n        success: true,\n        orderId: event.orderId,\n      };\n    } catch (error) {\n      this.logger.error(`Failed to process order ${event.orderId}:`, error);\n      throw error;\n    }\n  }\n\n  private async updateInventory(event: OrderCreatedEvent): Promise<void> {\n    await this.inventoryService.reserveItems(event.orderId);\n  }\n\n  private async sendNotification(event: OrderCreatedEvent): Promise<void> {\n    await this.notificationService.sendOrderConfirmation(event.orderId);\n  }\n\n  private async triggerWorkflow(event: OrderCreatedEvent): Promise<void> {\n    // Trigger additional workflows if needed\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"step-function-event-handler",children:"Step Function Event Handler"}),"\n",(0,s.jsx)(n.p,{children:"Handle events from Step Functions with task token support:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// import/event/import-process.event.handler.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport {\n  EventHandler,\n  IEventHandler,\n  StepFunctionService,\n  SnsService,\n  SnsEvent,\n} from '@mbc-cqrs-serverless/core';\nimport { ConfigService } from '@nestjs/config';\nimport { ImportProcessEvent } from './import-process.event';\nimport { ImportService } from '../import.service';\n\n// Define SNS event for alarm notifications\nclass AlarmSnsEvent extends SnsEvent {\n  importId: string;\n  bucket: string;\n  key: string;\n  errorMessage: string;\n  timestamp: string;\n}\n\n@EventHandler(ImportProcessEvent)\n@Injectable()\nexport class ImportProcessEventHandler\n  implements IEventHandler<ImportProcessEvent>\n{\n  private readonly logger = new Logger(ImportProcessEventHandler.name);\n  private readonly alarmTopicArn: string;\n\n  constructor(\n    private readonly importService: ImportService,\n    private readonly sfnService: StepFunctionService,\n    private readonly snsService: SnsService,\n    private readonly configService: ConfigService,\n  ) {\n    this.alarmTopicArn = this.configService.get<string>('SNS_ALARM_TOPIC_ARN');\n  }\n\n  /**\n   * Process import with Step Function callback\n   */\n  async execute(event: ImportProcessEvent): Promise<{ success: boolean; importId: string }> {\n    this.logger.log(`Processing import: ${event.importId}`);\n\n    try {\n      // Process the import\n      const result = await this.importService.processImport(event);\n\n      // Resume Step Functions execution on success\n      if (event.taskToken) {\n        await this.sfnService.resumeExecution(event.taskToken, result);\n      }\n\n      return { success: true, importId: event.importId };\n    } catch (error) {\n      this.logger.error(`Import failed: ${event.importId}`, error);\n\n      // Send alarm notification\n      await this.sendAlarm(event, error as Error);\n\n      throw error;\n    }\n  }\n\n  private async sendAlarm(event: ImportProcessEvent, error: Error): Promise<void> {\n    const alarmEvent: AlarmSnsEvent = {\n      action: 'IMPORT_ERROR',\n      importId: event.importId,\n      bucket: event.bucket,\n      key: event.key,\n      errorMessage: error.message,\n      timestamp: new Date().toISOString(),\n    };\n\n    await this.snsService.publish(alarmEvent, this.alarmTopicArn);\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"s3-event-handler",children:"S3 Event Handler"}),"\n",(0,s.jsx)(n.p,{children:"Process file uploads from S3:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// file/event/file-upload.event.ts\nexport class FileUploadEvent {\n  bucket: string;\n  key: string;\n  size: number;\n  eventType: string;\n\n  constructor(data: Partial<FileUploadEvent>) {\n    Object.assign(this, data);\n  }\n}\n\n// file/event/file-upload.handler.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { EventHandler, IEventHandler, S3Service } from '@mbc-cqrs-serverless/core';\nimport { GetObjectCommand } from '@aws-sdk/client-s3';\nimport { FileUploadEvent } from './file-upload.event';\nimport { FileProcessService } from '../file-process.service';\n\ninterface FileProcessingResult {\n  status: 'processed' | 'skipped';\n  fileType?: string;\n  reason?: string;\n}\n\n@EventHandler(FileUploadEvent)\n@Injectable()\nexport class FileUploadHandler implements IEventHandler<FileUploadEvent, FileProcessingResult> {\n  private readonly logger = new Logger(FileUploadHandler.name);\n\n  constructor(\n    private readonly s3Service: S3Service,\n    private readonly fileProcessService: FileProcessService,\n  ) {}\n\n  /**\n   * Process uploaded file\n   */\n  async execute(event: FileUploadEvent): Promise<FileProcessingResult> {\n    this.logger.log(`Processing file: ${event.key}`);\n\n    // Get file content from S3\n    const command = new GetObjectCommand({\n      Bucket: event.bucket,\n      Key: event.key,\n    });\n    const response = await this.s3Service.client.send(command);\n\n    // Determine file type and process accordingly\n    const fileExtension = event.key.split('.').pop()?.toLowerCase();\n\n    switch (fileExtension) {\n      case 'csv':\n        await this.fileProcessService.processCsv(response.Body, event);\n        return { status: 'processed', fileType: 'csv' };\n      case 'xlsx':\n      case 'xls':\n        await this.fileProcessService.processExcel(response.Body, event);\n        return { status: 'processed', fileType: fileExtension };\n      case 'pdf':\n        await this.fileProcessService.processPdf(response.Body, event);\n        return { status: 'processed', fileType: 'pdf' };\n      case 'jpg':\n      case 'jpeg':\n      case 'png':\n        await this.fileProcessService.processImage(response.Body, event);\n        return { status: 'processed', fileType: fileExtension };\n      default:\n        this.logger.warn(`Unsupported file type: ${fileExtension}`);\n        return { status: 'skipped', reason: 'Unsupported file type' };\n    }\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"sqs-event-handler",children:"SQS Event Handler"}),"\n",(0,s.jsx)(n.p,{children:"Process asynchronous messages from SQS:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// notification/event/send-notification.event.ts\nexport class SendNotificationEvent {\n  type: 'EMAIL' | 'SMS' | 'PUSH';\n  recipient: string;\n  subject: string;\n  body: string;\n  templateId?: string;\n  templateData?: Record<string, any>;\n\n  constructor(data: Partial<SendNotificationEvent>) {\n    Object.assign(this, data);\n  }\n}\n\n// notification/event/send-notification.handler.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport {\n  EventHandler,\n  IEventHandler,\n  EmailService,\n} from '@mbc-cqrs-serverless/core';\nimport { SendNotificationEvent } from './send-notification.event';\n\ninterface NotificationResult {\n  status: 'sent' | 'skipped';\n  type: 'EMAIL' | 'SMS' | 'PUSH';\n  reason?: string;\n}\n\n@EventHandler(SendNotificationEvent)\n@Injectable()\nexport class SendNotificationHandler\n  implements IEventHandler<SendNotificationEvent, NotificationResult>\n{\n  private readonly logger = new Logger(SendNotificationHandler.name);\n\n  constructor(private readonly emailService: EmailService) {}\n\n  /**\n   * Send notification based on type\n   */\n  async execute(event: SendNotificationEvent): Promise<NotificationResult> {\n    this.logger.log(`Sending ${event.type} notification to ${event.recipient}`);\n\n    switch (event.type) {\n      case 'EMAIL':\n        return this.sendEmail(event);\n      case 'SMS':\n        return this.sendSms(event);\n      case 'PUSH':\n        return this.sendPush(event);\n      default:\n        throw new Error(`Unknown notification type: ${event.type}`);\n    }\n  }\n\n  private async sendEmail(event: SendNotificationEvent): Promise<NotificationResult> {\n    let body = event.body;\n\n    // Render template if provided\n    if (event.templateId && event.templateData) {\n      body = await this.renderTemplate(event.templateId, event.templateData);\n    }\n\n    await this.emailService.sendEmail({\n      toAddrs: [event.recipient],\n      subject: event.subject,\n      body,\n    });\n\n    return { status: 'sent', type: 'EMAIL' };\n  }\n\n  private async sendSms(event: SendNotificationEvent): Promise<NotificationResult> {\n    // Implement SMS sending logic\n    this.logger.log('SMS sending not implemented');\n    return { status: 'skipped', type: 'SMS', reason: 'Not implemented' };\n  }\n\n  private async sendPush(event: SendNotificationEvent): Promise<NotificationResult> {\n    // Implement push notification logic\n    this.logger.log('Push notification not implemented');\n    return { status: 'skipped', type: 'PUSH', reason: 'Not implemented' };\n  }\n\n  private async renderTemplate(\n    templateId: string,\n    data: Record<string, any>,\n  ): Promise<string> {\n    // Template rendering logic\n    return `Template ${templateId} rendered with data`;\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"dynamodb-stream-handler",children:"DynamoDB Stream Handler"}),"\n",(0,s.jsx)(n.h3,{id:"data-change-event-handler",children:"Data Change Event Handler"}),"\n",(0,s.jsx)(n.p,{children:"React to data changes in DynamoDB:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// sync/event/data-change.event.ts\nexport class DataChangeEvent {\n  pk: string;\n  sk: string;\n  eventType: 'INSERT' | 'MODIFY' | 'REMOVE';\n  oldImage?: Record<string, any>;\n  newImage?: Record<string, any>;\n\n  constructor(data: Partial<DataChangeEvent>) {\n    Object.assign(this, data);\n  }\n}\n\n// sync/event/data-change.handler.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { EventHandler, IEventHandler } from '@mbc-cqrs-serverless/core';\nimport { DataChangeEvent } from './data-change.event';\nimport { ExternalSyncService } from '../external-sync.service';\nimport { CacheService } from '../../cache/cache.service';\n\ninterface DataSyncResult {\n  synced: boolean;\n  type?: string;\n}\n\n@EventHandler(DataChangeEvent)\n@Injectable()\nexport class DataChangeHandler implements IEventHandler<DataChangeEvent, DataSyncResult> {\n  private readonly logger = new Logger(DataChangeHandler.name);\n\n  constructor(\n    private readonly externalSyncService: ExternalSyncService,\n    private readonly cacheService: CacheService,\n  ) {}\n\n  /**\n   * Handle data changes from DynamoDB stream\n   */\n  async execute(event: DataChangeEvent): Promise<DataSyncResult> {\n    this.logger.log(\n      `Data change: ${event.eventType} on ${event.pk}/${event.sk}`,\n    );\n\n    // Invalidate cache\n    await this.cacheService.invalidate(event.pk, event.sk);\n\n    // Sync to external systems based on entity type\n    const entityType = event.pk.split('#')[0];\n\n    switch (entityType) {\n      case 'PRODUCT':\n        return this.syncProduct(event);\n      case 'ORDER':\n        return this.syncOrder(event);\n      case 'USER':\n        return this.syncUser(event);\n      default:\n        this.logger.debug(`No external sync for entity type: ${entityType}`);\n        return { synced: false };\n    }\n  }\n\n  private async syncProduct(event: DataChangeEvent): Promise<DataSyncResult> {\n    if (event.eventType === 'REMOVE') {\n      await this.externalSyncService.deleteProduct(event.pk, event.sk);\n    } else {\n      await this.externalSyncService.upsertProduct(event.newImage);\n    }\n    return { synced: true, type: 'PRODUCT' };\n  }\n\n  private async syncOrder(event: DataChangeEvent): Promise<DataSyncResult> {\n    // Sync order to external ERP system\n    await this.externalSyncService.syncOrder(event.newImage);\n    return { synced: true, type: 'ORDER' };\n  }\n\n  private async syncUser(event: DataChangeEvent): Promise<DataSyncResult> {\n    // Sync user to external identity provider\n    await this.externalSyncService.syncUser(event.newImage);\n    return { synced: true, type: 'USER' };\n  }\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"error-handling-and-retry",children:"Error Handling and Retry"}),"\n",(0,s.jsx)(n.p,{children:"The following patterns show how you can implement error handling and retry logic in your application. These are example implementations that you need to create in your own project."}),"\n",(0,s.jsx)(n.h3,{id:"retry-pattern-example",children:"Retry Pattern Example"}),"\n",(0,s.jsx)(n.admonition,{title:"Example Implementation",type:"info",children:(0,s.jsx)(n.p,{children:"The following retry decorator is not provided by the framework. You need to implement it yourself if you need retry functionality within Lambda execution."})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// common/event/retry.decorator.ts\nimport { Logger } from '@nestjs/common';\n\nexport interface RetryOptions {\n  maxRetries: number;\n  backoffMs: number;\n  backoffMultiplier: number;\n}\n\nconst DEFAULT_RETRY_OPTIONS: RetryOptions = {\n  maxRetries: 3,\n  backoffMs: 1000,\n  backoffMultiplier: 2,\n};\n\n/**\n * Example retry decorator for event handlers\n */\nexport function WithRetry(options: Partial<RetryOptions> = {}) {\n  const retryOptions = { ...DEFAULT_RETRY_OPTIONS, ...options };\n\n  return function (\n    target: any,\n    propertyKey: string,\n    descriptor: PropertyDescriptor,\n  ) {\n    const originalMethod = descriptor.value;\n    const logger = new Logger(`${target.constructor.name}.${propertyKey}`);\n\n    descriptor.value = async function (...args: any[]) {\n      let lastError: Error;\n      let delay = retryOptions.backoffMs;\n\n      for (let attempt = 1; attempt <= retryOptions.maxRetries; attempt++) {\n        try {\n          return await originalMethod.apply(this, args);\n        } catch (error) {\n          lastError = error;\n          logger.warn(\n            `Attempt ${attempt}/${retryOptions.maxRetries} failed: ${error.message}`,\n          );\n\n          if (attempt < retryOptions.maxRetries) {\n            await new Promise(resolve => setTimeout(resolve, delay));\n            delay *= retryOptions.backoffMultiplier;\n          }\n        }\n      }\n\n      logger.error(`All ${retryOptions.maxRetries} attempts failed`);\n      throw lastError!;\n    };\n\n    return descriptor;\n  };\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"aws-native-retry-options",children:"AWS Native Retry Options"}),"\n",(0,s.jsx)(n.p,{children:"For production use, consider using AWS-native retry mechanisms:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"SQS Retry"}),": Configure ",(0,s.jsx)(n.code,{children:"maxReceiveCount"})," on the SQS queue to automatically retry failed messages"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lambda Retry"}),": Configure retry settings on the Lambda function for asynchronous invocations"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Step Functions Retry"}),": Use the ",(0,s.jsx)(n.code,{children:"Retry"})," field in your state machine definition"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-idempotent-event-handlers",children:"1. Idempotent Event Handlers"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface IdempotentResult {\n  skipped?: boolean;\n  processed?: boolean;\n}\n\n// Always check if event was already processed\nasync execute(event: OrderEvent): Promise<IdempotentResult> {\n  const existing = await this.prismaService.processedEvent.findUnique({\n    where: { eventId: event.eventId },\n  });\n\n  if (existing) {\n    this.logger.log(`Event ${event.eventId} already processed, skipping`);\n    return { skipped: true };\n  }\n\n  // Process event\n  const result = await this.processEvent(event);\n\n  // Mark as processed\n  await this.prismaService.processedEvent.create({\n    data: { eventId: event.eventId, processedAt: new Date() },\n  });\n\n  return { processed: true, ...result };\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-structured-logging",children:"2. Structured Logging"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Use structured logging for better observability\nthis.logger.log({\n  message: 'Processing event',\n  eventType: event.constructor.name,\n  eventId: event.id,\n  tenantCode: event.tenantCode,\n  correlationId: event.correlationId,\n});\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-timeout-handling",children:"3. Timeout Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface TimeoutResult {\n  success: boolean;\n  data?: Record<string, unknown>;\n}\n\n// Implement timeout for long-running operations\nasync execute(event: LongRunningEvent): Promise<TimeoutResult> {\n  const timeout = 25000; // 25 seconds (Lambda default is 30s)\n\n  const result = await Promise.race([\n    this.processEvent(event),\n    new Promise<never>((_, reject) =>\n      setTimeout(() => reject(new Error('Operation timeout')), timeout),\n    ),\n  ]);\n\n  return result;\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-graceful-degradation",children:"4. Graceful Degradation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"interface BatchProcessingResult {\n  processed: number;\n  failed: number;\n}\n\n// Continue processing even if some operations fail\nasync execute(event: BatchEvent): Promise<BatchProcessingResult> {\n  const results: unknown[] = [];\n  const errors: Array<{ item: unknown; error: string }> = [];\n\n  for (const item of event.items) {\n    try {\n      results.push(await this.processItem(item));\n    } catch (error) {\n      errors.push({ item, error: (error as Error).message });\n      // Continue with next item\n    }\n  }\n\n  if (errors.length > 0) {\n    this.logger.warn(`${errors.length} items failed`, { errors });\n  }\n\n  return { processed: results.length, failed: errors.length };\n}\n"})}),"\n",(0,s.jsx)(n.h2,{id:"data-sync-handler",children:"Data Sync Handler"}),"\n",(0,s.jsx)(n.p,{children:"The data sync event is a particularly significant custom event because it is one of the most commonly registered events within the application. Handlers for this event play a crucial role in ensuring data consistency and synchronization between different databases."}),"\n",(0,s.jsx)(n.h3,{id:"idatasynchandler-interface",children:"IDataSyncHandler Interface"}),"\n",(0,s.jsxs)(n.p,{children:["By convention, you create a class that implements ",(0,s.jsx)(n.code,{children:"IDataSyncHandler"})," and then override the up and down methods:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'import { CommandModel, IDataSyncHandler } from "@mbc-cqrs-serverless/core";\nimport { Injectable, Logger } from "@nestjs/common";\nimport { PrismaService } from "src/prisma";\n\n@Injectable()\nexport class ProductDataSyncRdsHandler implements IDataSyncHandler<void, void> {\n  private readonly logger = new Logger(ProductDataSyncRdsHandler.name);\n\n  constructor(private readonly prismaService: PrismaService) {}\n\n  /**\n   * Sync data from DynamoDB to RDS on create/update\n   */\n  async up(cmd: CommandModel): Promise<void> {\n    this.logger.debug(\'Syncing to RDS:\', cmd.pk, cmd.sk);\n\n    const { pk, sk, id, code, name, tenantCode, attributes } = cmd;\n\n    await this.prismaService.product.upsert({\n      where: { id },\n      create: {\n        id,\n        pk,\n        sk,\n        code,\n        name,\n        tenantCode,\n        ...attributes,\n        createdAt: new Date(),\n        updatedAt: new Date(),\n      },\n      update: {\n        name,\n        ...attributes,\n        updatedAt: new Date(),\n      },\n    });\n  }\n\n  /**\n   * Handle delete/rollback operations\n   */\n  async down(cmd: CommandModel): Promise<void> {\n    this.logger.debug(\'Removing from RDS:\', cmd.pk, cmd.sk);\n\n    await this.prismaService.product.delete({\n      where: { id: cmd.id },\n    }).catch(() => {\n      // Ignore if already deleted\n    });\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"register-data-sync-handler",children:"Register Data Sync Handler"}),"\n",(0,s.jsxs)(n.p,{children:["Register your handler to ",(0,s.jsx)(n.code,{children:"CommandModule"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"import { Module } from '@nestjs/common';\nimport { CommandModule } from '@mbc-cqrs-serverless/core';\nimport { ProductDataSyncRdsHandler } from './handler/product-rds.handler';\n\n@Module({\n  imports: [\n    CommandModule.register({\n      tableName: 'product',\n      dataSyncHandlers: [ProductDataSyncRdsHandler],\n    }),\n  ],\n  // ...\n})\nexport class ProductModule {}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"multiple-sync-handlers",children:"Multiple Sync Handlers"}),"\n",(0,s.jsx)(n.p,{children:"You can register multiple handlers for different sync targets:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"CommandModule.register({\n  tableName: 'order',\n  dataSyncHandlers: [\n    OrderRdsSyncHandler,      // Sync to RDS for queries\n    OrderElasticSyncHandler,  // Sync to Elasticsearch for search\n    OrderAnalyticsSyncHandler, // Sync to analytics warehouse\n  ],\n}),\n"})}),"\n",(0,s.jsx)(n.h2,{id:"creating-custom-events",children:"Creating Custom Events"}),"\n",(0,s.jsxs)(n.p,{children:["To create a custom event, implement the ",(0,s.jsx)(n.code,{children:"IEvent"})," interface from ",(0,s.jsx)(n.code,{children:"@mbc-cqrs-serverless/core"}),". Depending on the event source, you should typically implement a second interface from the ",(0,s.jsx)(n.code,{children:"aws-lambda"})," library, such as ",(0,s.jsx)(n.code,{children:"SNSEventRecord"}),", ",(0,s.jsx)(n.code,{children:"SQSRecord"}),", ",(0,s.jsx)(n.code,{children:"DynamoDBRecord"}),", ",(0,s.jsx)(n.code,{children:"EventBridgeEvent"}),", ",(0,s.jsx)(n.code,{children:"S3EventRecord"}),", etc."]}),"\n",(0,s.jsx)(n.h3,{id:"custom-s3-event-example",children:"Custom S3 Event Example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:'// custom-s3-import.event.ts\nimport { IEvent } from "@mbc-cqrs-serverless/core";\nimport { S3EventRecord } from "aws-lambda";\n\nexport class CustomS3ImportEvent implements IEvent, Partial<S3EventRecord> {\n  source: string;\n  bucket: string;\n  key: string;\n  size: number;\n  eventType: string;\n\n  static fromS3Record(record: S3EventRecord): CustomS3ImportEvent {\n    const event = new CustomS3ImportEvent();\n    event.source = record.eventSource;\n    event.bucket = record.s3.bucket.name;\n    event.key = record.s3.object.key;\n    event.size = record.s3.object.size;\n    event.eventType = record.eventName;\n    return event;\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"event-factory-transform-methods",children:"Event Factory Transform Methods"}),"\n",(0,s.jsx)(n.p,{children:"The Event Factory supports transforming events from various AWS sources:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-typescript",children:"// Available transform methods in DefaultEventFactory\ntransformSqs(event: SQSEvent): Promise<IEvent[]>;\ntransformSns(event: SNSEvent): Promise<IEvent[]>;\ntransformDynamodbStream(event: DynamoDBStreamEvent): Promise<IEvent[]>;\ntransformEventBridge(event: EventBridgeEvent<any, any>): Promise<IEvent[]>;\ntransformStepFunction(event: StepFunctionsEvent<any>): Promise<IEvent[]>;\ntransformS3(event: S3Event): Promise<IEvent[]>;\n"})}),"\n",(0,s.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"./backend-development",children:"Backend Development Guide"})," - Core patterns"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"./architecture/step-functions",children:"Step Functions"})," - Workflow orchestration"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"./data-sync-handler-examples",children:"Data Sync Handler Examples"})," - Comprehensive sync examples"]}),"\n"]})]})}function v(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>i});var r=t(6540);const s={},a=r.createContext(s);function o(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);