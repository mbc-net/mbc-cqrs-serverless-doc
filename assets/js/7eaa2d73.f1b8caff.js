"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[3637],{8851:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>s,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"saas-example","title":"SaaS Application Example","description":"Multi-tenant SaaS application example with subscription management, usage tracking, and billing integration.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/saas-example.md","sourceDirName":".","slug":"/saas-example","permalink":"/docs/saas-example","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"description":"Multi-tenant SaaS application example with subscription management, usage tracking, and billing integration."},"sidebar":"tutorialSidebar","previous":{"title":"E-commerce Example","permalink":"/docs/ecommerce-example"},"next":{"title":"Survey Template","permalink":"/docs/survey-template"}}');var r=t(4848),i=t(8453);const s={description:"Multi-tenant SaaS application example with subscription management, usage tracking, and billing integration."},o="SaaS Application Example",c={},l=[{value:"Overview",id:"overview",level:2},{value:"Data Model",id:"data-model",level:2},{value:"Key Structure",id:"key-structure",level:3},{value:"Entity Definitions",id:"entity-definitions",level:3},{value:"Tenant Management",id:"tenant-management",level:2},{value:"Tenant Service Extension",id:"tenant-service-extension",level:3},{value:"Subscription Management",id:"subscription-management",level:2},{value:"Subscription Service",id:"subscription-service",level:3},{value:"Usage Metering",id:"usage-metering",level:2},{value:"Usage Service",id:"usage-service",level:3},{value:"Quota Guard",id:"quota-guard",level:3},{value:"Billing Integration",id:"billing-integration",level:2},{value:"Billing Event Handler",id:"billing-event-handler",level:3},{value:"API Key Management",id:"api-key-management",level:2},{value:"API Key Service",id:"api-key-service",level:3},{value:"API Endpoints",id:"api-endpoints",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Tenant Isolation",id:"1-tenant-isolation",level:3},{value:"2. Usage Tracking",id:"2-usage-tracking",level:3},{value:"3. Billing Events",id:"3-billing-events",level:3},{value:"See Also",id:"see-also",level:2}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"saas-application-example",children:"SaaS Application Example"})}),"\n",(0,r.jsx)(n.p,{children:"This example demonstrates a multi-tenant SaaS application with subscription management, usage tracking, and billing integration using MBC CQRS Serverless."}),"\n",(0,r.jsx)(n.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(n.p,{children:"The SaaS example covers:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Multi-tenant isolation with tenant hierarchy"}),"\n",(0,r.jsx)(n.li,{children:"Subscription and plan management"}),"\n",(0,r.jsx)(n.li,{children:"Usage metering and quota enforcement"}),"\n",(0,r.jsx)(n.li,{children:"Billing event generation"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"data-model",children:"Data Model"}),"\n",(0,r.jsx)(n.h3,{id:"key-structure",children:"Key Structure"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"Partition Key (pk)           Sort Key (sk)\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\nTENANT#acme-corp                 SUBSCRIPTION#SUB-001\nTENANT#acme-corp                 USAGE#2024-01\nTENANT#acme-corp                 USER#usr-001\nTENANT#acme-corp                 APIKEY#key-001\nMASTER#COMMON                    PLAN#starter\nMASTER#COMMON                    PLAN#professional\nMASTER#COMMON                    PLAN#enterprise\n"})}),"\n",(0,r.jsx)(n.h3,{id:"entity-definitions",children:"Entity Definitions"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Plan Entity (Master Data)\nexport interface PlanAttributes {\n  displayName: string;\n  monthlyPrice: number;\n  yearlyPrice: number;\n  currency: string;\n  features: PlanFeature[];\n  limits: PlanLimits;\n  isActive: boolean;\n}\n\nexport interface PlanLimits {\n  maxUsers: number;\n  maxApiCalls: number;\n  maxStorageGb: number;\n  maxProjects: number;\n}\n\n// Subscription Entity\nexport interface SubscriptionAttributes {\n  planCode: string;\n  billingCycle: 'monthly' | 'yearly';\n  status: SubscriptionStatus;\n  startDate: string;\n  endDate: string;\n  autoRenew: boolean;\n  paymentMethodId?: string;\n}\n\nexport type SubscriptionStatus =\n  | 'active'\n  | 'trial'\n  | 'past_due'\n  | 'cancelled'\n  | 'expired';\n\n// Usage Entity\nexport interface UsageAttributes {\n  period: string; // YYYY-MM\n  apiCalls: number;\n  storageUsedGb: number;\n  activeUsers: number;\n  projectCount: number;\n  lastUpdatedAt: string;\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"tenant-management",children:"Tenant Management"}),"\n",(0,r.jsx)(n.h3,{id:"tenant-service-extension",children:"Tenant Service Extension"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// tenant-setup.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { TenantService, IInvoke } from '@mbc-cqrs-serverless/core';\nimport { SubscriptionService } from './subscription.service';\n\n@Injectable()\nexport class TenantSetupService {\n  constructor(\n    private readonly tenantService: TenantService,\n    private readonly subscriptionService: SubscriptionService,\n  ) {}\n\n  // Create tenant with initial subscription\n  async provisionTenant(dto: ProvisionTenantDto, context: IInvoke) {\n    // Step 1: Create tenant\n    const tenant = await this.tenantService.createTenant(\n      {\n        code: dto.companySlug,\n        name: dto.companyName,\n        attributes: {\n          industry: dto.industry,\n          country: dto.country,\n          timezone: dto.timezone,\n        },\n      },\n      context,\n    );\n\n    // Step 2: Create trial subscription\n    await this.subscriptionService.createTrialSubscription(\n      dto.companySlug,\n      dto.planCode,\n      context,\n    );\n\n    // Step 3: Initialize usage tracking\n    await this.initializeUsageTracking(dto.companySlug, context);\n\n    return tenant;\n  }\n\n  private async initializeUsageTracking(\n    tenantCode: string,\n    context: IInvoke,\n  ) {\n    const currentPeriod = this.getCurrentPeriod();\n\n    await this.commandService.publishAsync(\n      {\n        pk: generatePk(tenantCode),\n        sk: `USAGE#${currentPeriod}`,\n        code: currentPeriod,\n        name: `Usage for ${currentPeriod}`,\n        tenantCode,\n        attributes: {\n          period: currentPeriod,\n          apiCalls: 0,\n          storageUsedGb: 0,\n          activeUsers: 0,\n          projectCount: 0,\n          lastUpdatedAt: new Date().toISOString(),\n        },\n      },\n      { invokeContext: context },\n    );\n  }\n\n  private getCurrentPeriod(): string {\n    const now = new Date();\n    return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"subscription-management",children:"Subscription Management"}),"\n",(0,r.jsx)(n.h3,{id:"subscription-service",children:"Subscription Service"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// subscription.service.ts\nimport { Injectable, BadRequestException } from '@nestjs/common';\nimport {\n  CommandService,\n  DataService,\n  MasterService,\n  IInvoke,\n  getUserContext,\n  generatePk,\n} from '@mbc-cqrs-serverless/core';\n\n@Injectable()\nexport class SubscriptionService {\n  constructor(\n    private readonly commandService: CommandService,\n    private readonly dataService: DataService,\n    private readonly masterService: MasterService,\n  ) {}\n\n  // Create trial subscription\n  async createTrialSubscription(\n    tenantCode: string,\n    planCode: string,\n    context: IInvoke,\n  ) {\n    const plan = await this.masterService.getByCode('PLAN', planCode);\n    if (!plan) {\n      throw new BadRequestException(`Plan ${planCode} not found`);\n    }\n\n    const trialDays = 14;\n    const startDate = new Date();\n    const endDate = new Date(startDate);\n    endDate.setDate(endDate.getDate() + trialDays);\n\n    const command = {\n      pk: generatePk(tenantCode),\n      sk: `SUBSCRIPTION#SUB-${Date.now()}`,\n      code: `SUB-${Date.now()}`,\n      name: `${plan.name} Subscription`,\n      tenantCode,\n      attributes: {\n        planCode,\n        billingCycle: 'monthly',\n        status: 'trial' as SubscriptionStatus,\n        startDate: startDate.toISOString(),\n        endDate: endDate.toISOString(),\n        autoRenew: true,\n      },\n    };\n\n    return this.commandService.publishAsync(command, { invokeContext: context });\n  }\n\n  // Upgrade/Downgrade subscription\n  async changePlan(\n    subscriptionCode: string,\n    newPlanCode: string,\n    context: IInvoke,\n  ) {\n    const { tenantCode } = getUserContext(context);\n    const pk = generatePk(tenantCode);\n    const sk = `SUBSCRIPTION#${subscriptionCode}`;\n\n    const current = await this.dataService.getItem({ pk, sk });\n    if (!current) {\n      throw new NotFoundException(`Subscription ${subscriptionCode} not found`);\n    }\n\n    // Validate plan exists\n    const newPlan = await this.masterService.getByCode('PLAN', newPlanCode);\n    if (!newPlan) {\n      throw new BadRequestException(`Plan ${newPlanCode} not found`);\n    }\n\n    // Validate upgrade/downgrade is allowed\n    await this.validatePlanChange(tenantCode, current.attributes, newPlan);\n\n    const command = {\n      ...current,\n      version: current.version,\n      attributes: {\n        ...current.attributes,\n        planCode: newPlanCode,\n        planChangedAt: new Date().toISOString(),\n      },\n    };\n\n    return this.commandService.publishAsync(command, { invokeContext: context });\n  }\n\n  // Cancel subscription\n  async cancelSubscription(\n    subscriptionCode: string,\n    reason: string,\n    context: IInvoke,\n  ) {\n    const { tenantCode } = getUserContext(context);\n    const pk = generatePk(tenantCode);\n    const sk = `SUBSCRIPTION#${subscriptionCode}`;\n\n    const current = await this.dataService.getItem({ pk, sk });\n    if (!current) {\n      throw new NotFoundException(`Subscription ${subscriptionCode} not found`);\n    }\n\n    const command = {\n      ...current,\n      version: current.version,\n      attributes: {\n        ...current.attributes,\n        status: 'cancelled' as SubscriptionStatus,\n        autoRenew: false,\n        cancellationReason: reason,\n        cancelledAt: new Date().toISOString(),\n      },\n    };\n\n    return this.commandService.publishAsync(command, { invokeContext: context });\n  }\n\n  private async validatePlanChange(\n    tenantCode: string,\n    currentSub: SubscriptionAttributes,\n    newPlan: any,\n  ) {\n    // Check current usage against new plan limits\n    const usage = await this.getCurrentUsage(tenantCode);\n\n    if (usage.activeUsers > newPlan.attributes.limits.maxUsers) {\n      throw new BadRequestException(\n        `Cannot downgrade: current users (${usage.activeUsers}) ` +\n        `exceeds new plan limit (${newPlan.attributes.limits.maxUsers})`\n      );\n    }\n\n    if (usage.storageUsedGb > newPlan.attributes.limits.maxStorageGb) {\n      throw new BadRequestException(\n        `Cannot downgrade: current storage (${usage.storageUsedGb}GB) ` +\n        `exceeds new plan limit (${newPlan.attributes.limits.maxStorageGb}GB)`\n      );\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"usage-metering",children:"Usage Metering"}),"\n",(0,r.jsx)(n.h3,{id:"usage-service",children:"Usage Service"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// usage.service.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport {\n  CommandService,\n  DataService,\n  MasterService,\n  IInvoke,\n  getUserContext,\n  generatePk,\n} from '@mbc-cqrs-serverless/core';\n\n@Injectable()\nexport class UsageService {\n  private readonly logger = new Logger(UsageService.name);\n\n  constructor(\n    private readonly commandService: CommandService,\n    private readonly dataService: DataService,\n    private readonly masterService: MasterService,\n  ) {}\n\n  // Track API call\n  async trackApiCall(context: IInvoke): Promise<void> {\n    await this.incrementUsage(context, 'apiCalls', 1);\n  }\n\n  // Track storage usage\n  async trackStorageChange(\n    deltaGb: number,\n    context: IInvoke,\n  ): Promise<void> {\n    await this.incrementUsage(context, 'storageUsedGb', deltaGb);\n  }\n\n  // Check if quota is exceeded\n  async checkQuota(\n    metric: keyof UsageAttributes,\n    context: IInvoke,\n  ): Promise<QuotaCheckResult> {\n    const { tenantCode } = getUserContext(context);\n\n    const [usage, subscription] = await Promise.all([\n      this.getCurrentUsage(tenantCode),\n      this.getActiveSubscription(tenantCode),\n    ]);\n\n    const plan = await this.masterService.getByCode(\n      'PLAN',\n      subscription.attributes.planCode\n    );\n\n    const limit = this.getLimit(plan, metric);\n    const current = usage.attributes[metric] as number;\n    const percentage = (current / limit) * 100;\n\n    return {\n      metric,\n      current,\n      limit,\n      percentage,\n      isExceeded: current >= limit,\n      isNearLimit: percentage >= 80,\n    };\n  }\n\n  // Get usage summary for billing\n  async getUsageSummary(\n    tenantCode: string,\n    period: string,\n  ): Promise<UsageSummary> {\n    const pk = generatePk(tenantCode);\n    const sk = `USAGE#${period}`;\n\n    const usage = await this.dataService.getItem({ pk, sk });\n    if (!usage) {\n      return {\n        period,\n        apiCalls: 0,\n        storageUsedGb: 0,\n        activeUsers: 0,\n        projectCount: 0,\n      };\n    }\n\n    return usage.attributes;\n  }\n\n  private async incrementUsage(\n    context: IInvoke,\n    metric: string,\n    delta: number,\n  ): Promise<void> {\n    const { tenantCode } = getUserContext(context);\n    const period = this.getCurrentPeriod();\n    const pk = generatePk(tenantCode);\n    const sk = `USAGE#${period}`;\n\n    const current = await this.dataService.getItem({ pk, sk });\n\n    if (!current) {\n      // Create new usage record\n      const command = {\n        pk,\n        sk,\n        code: period,\n        name: `Usage for ${period}`,\n        tenantCode,\n        attributes: {\n          period,\n          apiCalls: 0,\n          storageUsedGb: 0,\n          activeUsers: 0,\n          projectCount: 0,\n          [metric]: delta,\n          lastUpdatedAt: new Date().toISOString(),\n        },\n      };\n      await this.commandService.publishAsync(command, { invokeContext: context });\n      return;\n    }\n\n    // Update existing record\n    const command = {\n      ...current,\n      version: current.version,\n      attributes: {\n        ...current.attributes,\n        [metric]: (current.attributes[metric] || 0) + delta,\n        lastUpdatedAt: new Date().toISOString(),\n      },\n    };\n\n    await this.commandService.publishAsync(command, { invokeContext: context });\n  }\n\n  private getLimit(plan: any, metric: string): number {\n    const limitMapping: Record<string, string> = {\n      apiCalls: 'maxApiCalls',\n      storageUsedGb: 'maxStorageGb',\n      activeUsers: 'maxUsers',\n      projectCount: 'maxProjects',\n    };\n\n    return plan.attributes.limits[limitMapping[metric]] || Infinity;\n  }\n\n  private getCurrentPeriod(): string {\n    const now = new Date();\n    return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"quota-guard",children:"Quota Guard"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// quota.guard.ts\nimport { Injectable, CanActivate, ExecutionContext, ForbiddenException } from '@nestjs/common';\nimport { Reflector } from '@nestjs/core';\nimport { UsageService } from './usage.service';\nimport { getInvokeContext } from '@mbc-cqrs-serverless/core';\n\n@Injectable()\nexport class QuotaGuard implements CanActivate {\n  constructor(\n    private readonly reflector: Reflector,\n    private readonly usageService: UsageService,\n  ) {}\n\n  async canActivate(context: ExecutionContext): Promise<boolean> {\n    const metric = this.reflector.get<string>('quota_metric', context.getHandler());\n    if (!metric) {\n      return true;\n    }\n\n    const ctx = getInvokeContext(context);\n    const quota = await this.usageService.checkQuota(metric, ctx);\n\n    if (quota.isExceeded) {\n      throw new ForbiddenException(\n        `Quota exceeded for ${metric}: ${quota.current}/${quota.limit}. ` +\n        'Please upgrade your plan.'\n      );\n    }\n\n    return true;\n  }\n}\n\n// Usage in controller\n@Controller('projects')\nexport class ProjectController {\n  @Post()\n  @UseGuards(QuotaGuard)\n  @SetMetadata('quota_metric', 'projectCount')\n  async create(@Body() dto: CreateProjectDto, @Req() req: IInvoke) {\n    // ...\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"billing-integration",children:"Billing Integration"}),"\n",(0,r.jsx)(n.h3,{id:"billing-event-handler",children:"Billing Event Handler"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// billing-event.handler.ts\nimport { Injectable, Logger } from '@nestjs/common';\nimport { DataSyncHandler, IDataSyncHandler } from '@mbc-cqrs-serverless/core';\n\n@DataSyncHandler({ tableName: 'data-table' })\n@Injectable()\nexport class BillingEventHandler implements IDataSyncHandler {\n  private readonly logger = new Logger(BillingEventHandler.name);\n\n  constructor(private readonly billingService: BillingService) {}\n\n  async handleSync(event: DataSyncEvent): Promise<void> {\n    // Handle subscription changes\n    if (event.sk.startsWith('SUBSCRIPTION#')) {\n      await this.handleSubscriptionChange(event);\n      return;\n    }\n\n    // Handle usage updates\n    if (event.sk.startsWith('USAGE#')) {\n      await this.handleUsageChange(event);\n      return;\n    }\n  }\n\n  private async handleSubscriptionChange(event: DataSyncEvent) {\n    const { old: prev, new: current } = event;\n\n    // New subscription\n    if (!prev && current) {\n      this.logger.log(`New subscription: ${current.code}`);\n\n      if (current.attributes.status === 'active') {\n        await this.billingService.createBillingCycle({\n          tenantCode: current.tenantCode,\n          subscriptionCode: current.code,\n          planCode: current.attributes.planCode,\n          billingCycle: current.attributes.billingCycle,\n          startDate: current.attributes.startDate,\n        });\n      }\n      return;\n    }\n\n    // Subscription cancelled\n    if (\n      prev?.attributes.status !== 'cancelled' &&\n      current?.attributes.status === 'cancelled'\n    ) {\n      this.logger.log(`Subscription cancelled: ${current.code}`);\n      await this.billingService.cancelBillingCycle(current.code);\n      return;\n    }\n\n    // Plan changed\n    if (prev?.attributes.planCode !== current?.attributes.planCode) {\n      this.logger.log(\n        `Plan changed: ${prev.attributes.planCode} -> ${current.attributes.planCode}`\n      );\n      await this.billingService.prorate({\n        subscriptionCode: current.code,\n        oldPlanCode: prev.attributes.planCode,\n        newPlanCode: current.attributes.planCode,\n        changeDate: current.attributes.planChangedAt,\n      });\n    }\n  }\n\n  private async handleUsageChange(event: DataSyncEvent) {\n    const usage = event.new;\n    if (!usage) return;\n\n    // Check for overage\n    const subscription = await this.getActiveSubscription(usage.tenantCode);\n    const plan = await this.masterService.getByCode(\n      'PLAN',\n      subscription.attributes.planCode\n    );\n\n    const overages = this.calculateOverages(usage.attributes, plan.attributes.limits);\n\n    if (overages.length > 0) {\n      this.logger.log(`Overage detected for ${usage.tenantCode}`, overages);\n      await this.billingService.recordOverage({\n        tenantCode: usage.tenantCode,\n        period: usage.attributes.period,\n        overages,\n      });\n    }\n  }\n\n  private calculateOverages(\n    usage: UsageAttributes,\n    limits: PlanLimits,\n  ): Overage[] {\n    const overages: Overage[] = [];\n\n    if (usage.apiCalls > limits.maxApiCalls) {\n      overages.push({\n        metric: 'apiCalls',\n        limit: limits.maxApiCalls,\n        actual: usage.apiCalls,\n        overage: usage.apiCalls - limits.maxApiCalls,\n      });\n    }\n\n    if (usage.storageUsedGb > limits.maxStorageGb) {\n      overages.push({\n        metric: 'storageUsedGb',\n        limit: limits.maxStorageGb,\n        actual: usage.storageUsedGb,\n        overage: usage.storageUsedGb - limits.maxStorageGb,\n      });\n    }\n\n    return overages;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"api-key-management",children:"API Key Management"}),"\n",(0,r.jsx)(n.h3,{id:"api-key-service",children:"API Key Service"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// api-key.service.ts\nimport { Injectable } from '@nestjs/common';\nimport { randomBytes, createHash } from 'crypto';\nimport {\n  CommandService,\n  DataService,\n  IInvoke,\n  getUserContext,\n  generatePk,\n} from '@mbc-cqrs-serverless/core';\n\n@Injectable()\nexport class ApiKeyService {\n  constructor(\n    private readonly commandService: CommandService,\n    private readonly dataService: DataService,\n  ) {}\n\n  // Generate new API key\n  async createApiKey(dto: CreateApiKeyDto, context: IInvoke) {\n    const { tenantCode, userId } = getUserContext(context);\n\n    // Generate secure API key\n    const rawKey = `mbc_${randomBytes(32).toString('hex')}`;\n    const keyHash = this.hashKey(rawKey);\n    const keyPrefix = rawKey.substring(0, 11); // Show first 11 chars\n\n    const command = {\n      pk: generatePk(tenantCode),\n      sk: `APIKEY#${keyHash}`,\n      code: keyHash,\n      name: dto.name,\n      tenantCode,\n      attributes: {\n        keyPrefix,\n        keyHash,\n        createdBy: userId,\n        scopes: dto.scopes || ['read'],\n        expiresAt: dto.expiresAt,\n        lastUsedAt: null,\n        isActive: true,\n      },\n    };\n\n    await this.commandService.publishAsync(command, { invokeContext: context });\n\n    // Return raw key only once\n    return {\n      key: rawKey,\n      keyPrefix,\n      name: dto.name,\n      scopes: dto.scopes,\n    };\n  }\n\n  // Validate API key\n  async validateApiKey(rawKey: string): Promise<ApiKeyValidation> {\n    const keyHash = this.hashKey(rawKey);\n\n    // Search across all tenants - use GSI in production\n    const result = await this.dataService.query({\n      indexName: 'GSI-APIKEY',\n      pk: keyHash,\n    });\n\n    if (!result.items.length) {\n      return { valid: false, reason: 'Key not found' };\n    }\n\n    const apiKey = result.items[0];\n\n    if (!apiKey.attributes.isActive) {\n      return { valid: false, reason: 'Key is inactive' };\n    }\n\n    if (\n      apiKey.attributes.expiresAt &&\n      new Date(apiKey.attributes.expiresAt) < new Date()\n    ) {\n      return { valid: false, reason: 'Key expired' };\n    }\n\n    // Update last used timestamp asynchronously\n    this.updateLastUsed(apiKey).catch(() => {});\n\n    return {\n      valid: true,\n      tenantCode: apiKey.tenantCode,\n      scopes: apiKey.attributes.scopes,\n    };\n  }\n\n  // Revoke API key\n  async revokeApiKey(keyPrefix: string, context: IInvoke) {\n    const { tenantCode } = getUserContext(context);\n    const pk = generatePk(tenantCode);\n\n    // Find key by prefix\n    const keys = await this.dataService.listItemsByPk(pk, {\n      sk: { $beginsWith: 'APIKEY#' },\n    });\n\n    const apiKey = keys.items.find(\n      (k) => k.attributes.keyPrefix === keyPrefix\n    );\n\n    if (!apiKey) {\n      throw new NotFoundException('API key not found');\n    }\n\n    const command = {\n      ...apiKey,\n      version: apiKey.version,\n      attributes: {\n        ...apiKey.attributes,\n        isActive: false,\n        revokedAt: new Date().toISOString(),\n      },\n    };\n\n    return this.commandService.publishAsync(command, { invokeContext: context });\n  }\n\n  private hashKey(rawKey: string): string {\n    return createHash('sha256').update(rawKey).digest('hex');\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"api-endpoints",children:"API Endpoints"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Method"}),(0,r.jsx)(n.th,{children:"Endpoint"}),(0,r.jsx)(n.th,{children:"Description"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POST"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/tenants/provision"})}),(0,r.jsx)(n.td,{children:"Provision new tenant"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"GET"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/subscription"})}),(0,r.jsx)(n.td,{children:"Get current subscription"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"PATCH"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/subscription/plan"})}),(0,r.jsx)(n.td,{children:"Change plan"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POST"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/subscription/cancel"})}),(0,r.jsx)(n.td,{children:"Cancel subscription"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"GET"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/usage"})}),(0,r.jsx)(n.td,{children:"Get current usage"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"GET"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/usage/:period"})}),(0,r.jsx)(n.td,{children:"Get usage for period"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"POST"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/api-keys"})}),(0,r.jsx)(n.td,{children:"Create API key"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"DELETE"}),(0,r.jsx)(n.td,{children:(0,r.jsx)(n.code,{children:"/api-keys/:prefix"})}),(0,r.jsx)(n.td,{children:"Revoke API key"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-tenant-isolation",children:"1. Tenant Isolation"}),"\n",(0,r.jsx)(n.p,{children:"Always scope data access by tenant:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const { tenantCode } = getUserContext(context);\nconst pk = generatePk(tenantCode);\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-usage-tracking",children:"2. Usage Tracking"}),"\n",(0,r.jsx)(n.p,{children:"Track usage incrementally, not on every request:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Batch updates using a buffer\nprivate usageBuffer = new Map<string, number>();\n\nasync trackApiCall(tenantCode: string) {\n  const current = this.usageBuffer.get(tenantCode) || 0;\n  this.usageBuffer.set(tenantCode, current + 1);\n\n  // Flush every 100 calls or 60 seconds\n  if (current + 1 >= 100) {\n    await this.flushUsage(tenantCode);\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-billing-events",children:"3. Billing Events"}),"\n",(0,r.jsx)(n.p,{children:"Use event handlers for billing, not synchronous calls:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Good: Event-driven billing\n@DataSyncHandler({ tableName: 'data-table' })\nexport class BillingEventHandler {\n  // Async, decoupled, reliable\n}\n\n// Avoid: Synchronous billing calls\nasync createSubscription() {\n  await this.createInStripe(); // Can fail, blocks user\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"see-also",children:"See Also"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"./tenant",children:"Tenant Module"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"./master",children:"Master Module"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"./multi-tenant-patterns",children:"Multi-Tenant Patterns"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"./event-handling-patterns",children:"Event Handling Patterns"})}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>o});var a=t(6540);const r={},i=a.createContext(r);function s(e){const n=a.useContext(i);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),a.createElement(i.Provider,{value:n},e.children)}}}]);