"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[7398],{5715:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>d});const i=JSON.parse('{"id":"service-patterns","title":"Service Implementation Patterns","description":"Learn how to implement service layer with CRUD operations using CommandService and DataService.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/service-patterns.md","sourceDirName":".","slug":"/service-patterns","permalink":"/docs/service-patterns","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"description":"Learn how to implement service layer with CRUD operations using CommandService and DataService."},"sidebar":"tutorialSidebar","previous":{"title":"Data Sync Handler Examples","permalink":"/docs/data-sync-handler-examples"},"next":{"title":"Multi-Tenant Patterns","permalink":"/docs/multi-tenant-patterns"}}');var o=t(4848),r=t(8453);const s={description:"Learn how to implement service layer with CRUD operations using CommandService and DataService."},a="Service Implementation Patterns",c={},d=[{value:"When to Use This Guide",id:"when-to-use-this-guide",level:2},{value:"Problems This Pattern Solves",id:"problems-this-pattern-solves",level:2},{value:"Basic Service Structure",id:"basic-service-structure",level:2},{value:"Create Operation",id:"create-operation",level:2},{value:"Use Case: Create a New Product",id:"use-case-create-a-new-product",level:3},{value:"Read Operations",id:"read-operations",level:2},{value:"Find One by Key",id:"find-one-by-key",level:3},{value:"Use Case: Get Product Detail Page",id:"use-case-get-product-detail-page",level:4},{value:"Find All with Pagination (from RDS)",id:"find-all-with-pagination-from-rds",level:3},{value:"Use Case: Product List with Filtering",id:"use-case-product-list-with-filtering",level:4},{value:"Update Operation",id:"update-operation",level:2},{value:"Use Case: Edit Product Details",id:"use-case-edit-product-details",level:3},{value:"Delete Operation (Soft Delete)",id:"delete-operation-soft-delete",level:2},{value:"Use Case: Remove Product from Catalog",id:"use-case-remove-product-from-catalog",level:3},{value:"Complete Service Example",id:"complete-service-example",level:2},{value:"Batch Operations",id:"batch-operations",level:2},{value:"Use Case: Import Multiple Products",id:"use-case-import-multiple-products",level:3},{value:"Chunked Batch Operations",id:"chunked-batch-operations",level:2},{value:"Use Case: Large Data Migration",id:"use-case-large-data-migration",level:3},{value:"Copy Operation",id:"copy-operation",level:2},{value:"Use Case: Clone Product to Different Tenant",id:"use-case-clone-product-to-different-tenant",level:3},{value:"Using History Service",id:"using-history-service",level:2},{value:"Use Case: View Previous Versions of a Document",id:"use-case-view-previous-versions-of-a-document",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Always Use Invoke Context",id:"1-always-use-invoke-context",level:3},{value:"2. Use Optimistic Locking",id:"2-use-optimistic-locking",level:3},{value:"3. Prefer Async Operations",id:"3-prefer-async-operations",level:3},{value:"4. Combine DynamoDB and RDS Queries",id:"4-combine-dynamodb-and-rds-queries",level:3}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"service-implementation-patterns",children:"Service Implementation Patterns"})}),"\n",(0,o.jsx)(n.p,{children:"This guide explains how to implement service classes that handle CRUD operations in MBC CQRS Serverless. Services are the core of your business logic, coordinating between controllers, commands, and data access."}),"\n",(0,o.jsx)(n.h2,{id:"when-to-use-this-guide",children:"When to Use This Guide"}),"\n",(0,o.jsx)(n.p,{children:"Use this guide when you need to:"}),"\n",(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsx)(n.li,{children:"Build a service layer for a new domain entity"}),"\n",(0,o.jsx)(n.li,{children:"Implement create, read, update, delete (CRUD) operations"}),"\n",(0,o.jsx)(n.li,{children:"Handle multi-tenant data isolation"}),"\n",(0,o.jsx)(n.li,{children:"Use optimistic locking for concurrent updates"}),"\n",(0,o.jsx)(n.li,{children:"Implement batch operations for bulk data processing"}),"\n"]}),"\n",(0,o.jsx)(n.h2,{id:"problems-this-pattern-solves",children:"Problems This Pattern Solves"}),"\n",(0,o.jsxs)(n.table,{children:[(0,o.jsx)(n.thead,{children:(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.th,{children:"Problem"}),(0,o.jsx)(n.th,{children:"Solution"})]})}),(0,o.jsxs)(n.tbody,{children:[(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Direct database access bypasses CQRS pattern"}),(0,o.jsx)(n.td,{children:"Use CommandService for writes, DataService for reads"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"No audit trail for data changes"}),(0,o.jsx)(n.td,{children:"Pass invokeContext to capture user and timestamp"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Concurrent updates overwrite each other"}),(0,o.jsx)(n.td,{children:"Use version field for optimistic locking"})]}),(0,o.jsxs)(n.tr,{children:[(0,o.jsx)(n.td,{children:"Slow responses due to synchronous processing"}),(0,o.jsx)(n.td,{children:"Use publishAsync for non-blocking command publishing"})]})]})]}),"\n",(0,o.jsx)(n.h2,{id:"basic-service-structure",children:"Basic Service Structure"}),"\n",(0,o.jsxs)(n.p,{children:["A typical service uses both ",(0,o.jsx)(n.code,{children:"CommandService"})," for write operations and ",(0,o.jsx)(n.code,{children:"DataService"})," for read operations:"]}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import {\n  CommandService,\n  DataService,\n  generateId,\n  getUserContext,\n  IInvoke,\n  VERSION_FIRST,\n  KEY_SEPARATOR,\n} from "@mbc-cqrs-serverless/core";\nimport { Injectable } from "@nestjs/common";\nimport { ulid } from "ulid";\n\nimport { PrismaService } from "src/prisma";\nimport { ProductCommandDto } from "./dto/product-command.dto";\nimport { ProductDataEntity } from "./entity/product-data.entity";\nimport { CreateProductDto } from "./dto/create-product.dto";\nimport { UpdateProductDto } from "./dto/update-product.dto";\n\nconst PRODUCT_PK_PREFIX = "PRODUCT";\n\n@Injectable()\nexport class ProductService {\n  constructor(\n    private readonly commandService: CommandService,\n    private readonly dataService: DataService,\n    private readonly prismaService: PrismaService,\n  ) {}\n\n  // CRUD methods will be implemented below\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"create-operation",children:"Create Operation"}),"\n",(0,o.jsx)(n.h3,{id:"use-case-create-a-new-product",children:"Use Case: Create a New Product"}),"\n",(0,o.jsx)(n.p,{children:"Scenario: User submits a form to add a new product to the catalog."}),"\n",(0,o.jsx)(n.p,{children:"Flow: Controller receives CreateProductDto \u2192 Service generates keys \u2192 Command published to DynamoDB \u2192 Data synced to RDS."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'async create(\n  createDto: CreateProductDto,\n  opts: { invokeContext: IInvoke },\n): Promise<ProductDataEntity> {\n  // Get tenant context from the invoke context\n  const { tenantCode } = getUserContext(opts.invokeContext);\n\n  // Generate PK and SK\n  const pk = `${PRODUCT_PK_PREFIX}${KEY_SEPARATOR}${tenantCode}`;\n  const sk = ulid(); // Use ULID for sortable unique ID\n  const id = generateId(pk, sk);\n\n  // Create command DTO\n  const command = new ProductCommandDto({\n    pk,\n    sk,\n    id,\n    tenantCode,\n    code: sk,\n    type: "PRODUCT",\n    name: createDto.name,\n    version: VERSION_FIRST,\n    attributes: {\n      description: createDto.description,\n      price: createDto.price,\n      category: createDto.category,\n      inStock: createDto.inStock ?? true,\n    },\n  });\n\n  // Publish command (async - returns immediately)\n  const item = await this.commandService.publishAsync(command, {\n    invokeContext: opts.invokeContext,\n  });\n\n  return new ProductDataEntity(item);\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"read-operations",children:"Read Operations"}),"\n",(0,o.jsx)(n.h3,{id:"find-one-by-key",children:"Find One by Key"}),"\n",(0,o.jsx)(n.h4,{id:"use-case-get-product-detail-page",children:"Use Case: Get Product Detail Page"}),"\n",(0,o.jsx)(n.p,{children:"Scenario: User navigates to a product detail page and needs the full product data."}),"\n",(0,o.jsx)(n.p,{children:"When to use: Single-item lookup where you have the pk and sk."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"async findOne(\n  detailDto: { pk: string; sk: string },\n): Promise<ProductDataEntity> {\n  const item = await this.dataService.getItem(detailDto);\n  return new ProductDataEntity(item);\n}\n"})}),"\n",(0,o.jsx)(n.h3,{id:"find-all-with-pagination-from-rds",children:"Find All with Pagination (from RDS)"}),"\n",(0,o.jsx)(n.h4,{id:"use-case-product-list-with-filtering",children:"Use Case: Product List with Filtering"}),"\n",(0,o.jsx)(n.p,{children:"Scenario: Display a paginated product list that users can filter by category or search."}),"\n",(0,o.jsx)(n.p,{children:"Why RDS: DynamoDB is not optimized for complex queries. Use Prisma/RDS for filtering and full-text search."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'async findAll(\n  searchDto: {\n    tenantCode: string;\n    category?: string;\n    inStock?: boolean;\n    page?: number;\n    limit?: number;\n  },\n): Promise<{ items: ProductDataEntity[]; total: number }> {\n  const page = searchDto.page ?? 1;\n  const limit = searchDto.limit ?? 20;\n  const skip = (page - 1) * limit;\n\n  // Build where clause\n  const where: any = {\n    tenantCode: searchDto.tenantCode,\n    isDeleted: false,\n  };\n\n  if (searchDto.category) {\n    where.category = searchDto.category;\n  }\n\n  if (searchDto.inStock !== undefined) {\n    where.inStock = searchDto.inStock;\n  }\n\n  // Execute parallel queries for count and data\n  const [total, items] = await Promise.all([\n    this.prismaService.product.count({ where }),\n    this.prismaService.product.findMany({\n      where,\n      take: limit,\n      skip,\n      orderBy: { createdAt: "desc" },\n    }),\n  ]);\n\n  return {\n    total,\n    items: items.map((item) => new ProductDataEntity(item)),\n  };\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"update-operation",children:"Update Operation"}),"\n",(0,o.jsx)(n.h3,{id:"use-case-edit-product-details",children:"Use Case: Edit Product Details"}),"\n",(0,o.jsx)(n.p,{children:"Scenario: User updates product name or price through an edit form."}),"\n",(0,o.jsx)(n.p,{children:"Important: Include the version field to enable optimistic locking and prevent concurrent update conflicts."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import {\n  CommandPartialInputModel,\n  CommandService,\n  DataService,\n  IInvoke,\n} from "@mbc-cqrs-serverless/core";\nimport { NotFoundException } from "@nestjs/common";\n\nasync update(\n  detailDto: { pk: string; sk: string },\n  updateDto: UpdateProductDto,\n  opts: { invokeContext: IInvoke },\n): Promise<ProductDataEntity> {\n  // First, get the existing item\n  const existing = await this.dataService.getItem(detailDto);\n\n  if (!existing) {\n    throw new NotFoundException("Product not found");\n  }\n\n  // Merge existing attributes with updates\n  const updatedAttributes = {\n    ...existing.attributes,\n    ...updateDto.attributes,\n  };\n\n  // Create partial update command\n  const command: CommandPartialInputModel = {\n    pk: existing.pk,\n    sk: existing.sk,\n    version: existing.version, // Required for optimistic locking\n    name: updateDto.name ?? existing.name,\n    attributes: updatedAttributes,\n  };\n\n  // Publish partial update\n  const item = await this.commandService.publishPartialUpdateAsync(command, {\n    invokeContext: opts.invokeContext,\n  });\n\n  return new ProductDataEntity(item);\n}\n'})}),"\n",(0,o.jsxs)(n.admonition,{title:"Version Parameter Behavior",type:"info",children:[(0,o.jsxs)(n.p,{children:["The ",(0,o.jsx)(n.code,{children:"version"})," field in ",(0,o.jsx)(n.code,{children:"publishPartialUpdateAsync()"})," controls how the existing item is retrieved:"]}),(0,o.jsxs)(n.ul,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"version > 0"})}),": Uses the specified version number. The command will fail if the version doesn't match (optimistic locking)."]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:(0,o.jsx)(n.code,{children:"version <= 0"})})," (e.g., ",(0,o.jsx)(n.code,{children:"VERSION_LATEST = -1"}),"): Automatically retrieves the latest version using ",(0,o.jsx)(n.code,{children:"getLatestItem()"}),"."]}),"\n"]}),(0,o.jsxs)(n.p,{children:["Use ",(0,o.jsx)(n.code,{children:"existing.version"})," (as shown above) for strict optimistic locking. Use ",(0,o.jsx)(n.code,{children:"VERSION_LATEST"})," (-1) when you want to always update the latest version regardless of what version you have cached."]})]}),"\n",(0,o.jsx)(n.h2,{id:"delete-operation-soft-delete",children:"Delete Operation (Soft Delete)"}),"\n",(0,o.jsx)(n.h3,{id:"use-case-remove-product-from-catalog",children:"Use Case: Remove Product from Catalog"}),"\n",(0,o.jsx)(n.p,{children:"Scenario: Admin removes a discontinued product."}),"\n",(0,o.jsx)(n.p,{children:"Why Soft Delete: Data is marked as deleted (isDeleted=true) rather than physically removed, preserving audit history."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import {\n  CommandPartialInputModel,\n  CommandService,\n  DataService,\n  IInvoke,\n} from "@mbc-cqrs-serverless/core";\nimport { NotFoundException } from "@nestjs/common";\n\nasync remove(\n  detailDto: { pk: string; sk: string },\n  opts: { invokeContext: IInvoke },\n): Promise<ProductDataEntity> {\n  // Get existing item\n  const existing = await this.dataService.getItem(detailDto);\n\n  if (!existing) {\n    throw new NotFoundException("Product not found");\n  }\n\n  // Create soft delete command\n  const command: CommandPartialInputModel = {\n    pk: existing.pk,\n    sk: existing.sk,\n    version: existing.version,\n    isDeleted: true,\n  };\n\n  const item = await this.commandService.publishPartialUpdateAsync(command, {\n    invokeContext: opts.invokeContext,\n  });\n\n  return new ProductDataEntity(item);\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"complete-service-example",children:"Complete Service Example"}),"\n",(0,o.jsx)(n.p,{children:"Here is a complete service implementation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import {\n  CommandPartialInputModel,\n  CommandService,\n  DataService,\n  generateId,\n  getUserContext,\n  VERSION_FIRST,\n  KEY_SEPARATOR,\n  IInvoke,\n} from "@mbc-cqrs-serverless/core";\nimport { Injectable, NotFoundException } from "@nestjs/common";\nimport { ulid } from "ulid";\n\nimport { PrismaService } from "src/prisma";\nimport { ProductCommandDto } from "./dto/product-command.dto";\nimport { ProductDataEntity } from "./entity/product-data.entity";\nimport { ProductListEntity } from "./entity/product-list.entity";\nimport { CreateProductDto } from "./dto/create-product.dto";\nimport { UpdateProductDto } from "./dto/update-product.dto";\nimport { SearchProductDto } from "./dto/search-product.dto";\nimport { DetailDto } from "./dto/detail.dto";\n\nconst PRODUCT_PK_PREFIX = "PRODUCT";\n\n@Injectable()\nexport class ProductService {\n  constructor(\n    private readonly commandService: CommandService,\n    private readonly dataService: DataService,\n    private readonly prismaService: PrismaService,\n  ) {}\n\n  /**\n   * Create a new product\n   */\n  async create(\n    createDto: CreateProductDto,\n    opts: { invokeContext: IInvoke },\n  ): Promise<ProductDataEntity> {\n    const { tenantCode } = getUserContext(opts.invokeContext);\n\n    const pk = `${PRODUCT_PK_PREFIX}${KEY_SEPARATOR}${tenantCode}`;\n    const sk = ulid();\n    const id = generateId(pk, sk);\n\n    const command = new ProductCommandDto({\n      pk,\n      sk,\n      id,\n      tenantCode,\n      code: sk,\n      type: "PRODUCT",\n      name: createDto.name,\n      version: VERSION_FIRST,\n      attributes: {\n        description: createDto.description,\n        price: createDto.price,\n        category: createDto.category,\n        inStock: createDto.inStock ?? true,\n      },\n    });\n\n    const item = await this.commandService.publishAsync(command, {\n      invokeContext: opts.invokeContext,\n    });\n\n    return new ProductDataEntity(item);\n  }\n\n  /**\n   * Find all products with filtering and pagination\n   */\n  async findAll(searchDto: SearchProductDto): Promise<ProductListEntity> {\n    const page = searchDto.page ?? 1;\n    const limit = searchDto.limit ?? 20;\n    const skip = (page - 1) * limit;\n\n    const where: any = {\n      tenantCode: searchDto.tenantCode,\n      isDeleted: false,\n    };\n\n    if (searchDto.category) {\n      where.category = searchDto.category;\n    }\n\n    if (searchDto.inStock !== undefined) {\n      where.inStock = searchDto.inStock;\n    }\n\n    if (searchDto.search) {\n      where.OR = [\n        { name: { contains: searchDto.search}},\n        { description: { contains: searchDto.search}},\n      ];\n    }\n\n    const [total, items] = await Promise.all([\n      this.prismaService.product.count({ where }),\n      this.prismaService.product.findMany({\n        where,\n        take: limit,\n        skip,\n        orderBy: { createdAt: "desc" },\n      }),\n    ]);\n\n    return new ProductListEntity({\n      total,\n      items: items.map((item) => new ProductDataEntity(item)),\n    });\n  }\n\n  /**\n   * Find one product by key\n   */\n  async findOne(detailDto: DetailDto): Promise<ProductDataEntity> {\n    const item = await this.dataService.getItem(detailDto);\n\n    if (!item) {\n      throw new NotFoundException("Product not found");\n    }\n\n    return new ProductDataEntity(item);\n  }\n\n  /**\n   * Update a product\n   */\n  async update(\n    detailDto: DetailDto,\n    updateDto: UpdateProductDto,\n    opts: { invokeContext: IInvoke },\n  ): Promise<ProductDataEntity> {\n    const existing = await this.dataService.getItem(detailDto);\n\n    if (!existing) {\n      throw new NotFoundException("Product not found");\n    }\n\n    const command: CommandPartialInputModel = {\n      pk: existing.pk,\n      sk: existing.sk,\n      version: existing.version,\n      name: updateDto.name ?? existing.name,\n      attributes: {\n        ...existing.attributes,\n        ...updateDto.attributes,\n      },\n    };\n\n    const item = await this.commandService.publishPartialUpdateAsync(command, {\n      invokeContext: opts.invokeContext,\n    });\n\n    return new ProductDataEntity(item);\n  }\n\n  /**\n   * Soft delete a product\n   */\n  async remove(\n    detailDto: DetailDto,\n    opts: { invokeContext: IInvoke },\n  ): Promise<ProductDataEntity> {\n    const existing = await this.dataService.getItem(detailDto);\n\n    if (!existing) {\n      throw new NotFoundException("Product not found");\n    }\n\n    const command: CommandPartialInputModel = {\n      pk: existing.pk,\n      sk: existing.sk,\n      version: existing.version,\n      isDeleted: true,\n    };\n\n    const item = await this.commandService.publishPartialUpdateAsync(command, {\n      invokeContext: opts.invokeContext,\n    });\n\n    return new ProductDataEntity(item);\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"batch-operations",children:"Batch Operations"}),"\n",(0,o.jsx)(n.h3,{id:"use-case-import-multiple-products",children:"Use Case: Import Multiple Products"}),"\n",(0,o.jsx)(n.p,{children:"Scenario: Admin uploads a CSV file containing multiple products to import."}),"\n",(0,o.jsx)(n.p,{children:"Solution: Process items in parallel using Promise.all for better performance."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'async createBatch(\n  items: CreateProductDto[],\n  opts: { invokeContext: IInvoke },\n): Promise<ProductDataEntity[]> {\n  const { tenantCode } = getUserContext(opts.invokeContext);\n  const pk = `${PRODUCT_PK_PREFIX}${KEY_SEPARATOR}${tenantCode}`;\n\n  // Create all commands\n  const commands = items.map((item) => {\n    const sk = ulid();\n    return new ProductCommandDto({\n      pk,\n      sk,\n      id: generateId(pk, sk),\n      tenantCode,\n      code: sk,\n      type: "PRODUCT",\n      name: item.name,\n      version: VERSION_FIRST,\n      attributes: {\n        description: item.description,\n        price: item.price,\n        category: item.category,\n        inStock: item.inStock ?? true,\n      },\n    });\n  });\n\n  // Publish all commands in parallel\n  const results = await Promise.all(\n    commands.map((command) =>\n      this.commandService.publishAsync(command, {\n        invokeContext: opts.invokeContext,\n      }),\n    ),\n  );\n\n  return results.map((item) => new ProductDataEntity(item));\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"chunked-batch-operations",children:"Chunked Batch Operations"}),"\n",(0,o.jsx)(n.h3,{id:"use-case-large-data-migration",children:"Use Case: Large Data Migration"}),"\n",(0,o.jsx)(n.p,{children:"Scenario: Migrating thousands of records from a legacy system."}),"\n",(0,o.jsx)(n.p,{children:"Problem: Processing all at once may cause Lambda timeout or memory issues."}),"\n",(0,o.jsx)(n.p,{children:"Solution: Process in chunks of 100 items to stay within Lambda limits."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'async createLargeBatch(\n  items: CreateProductDto[],\n  opts: { invokeContext: IInvoke },\n): Promise<ProductDataEntity[]> {\n  const { tenantCode } = getUserContext(opts.invokeContext);\n  const pk = `${PRODUCT_PK_PREFIX}${KEY_SEPARATOR}${tenantCode}`;\n\n  const chunkSize = 100;\n  const results: ProductDataEntity[] = [];\n\n  for (let i = 0; i < items.length; i += chunkSize) {\n    const chunk = items.slice(i, i + chunkSize);\n\n    const commands = chunk.map((item) => {\n      const sk = ulid();\n      return new ProductCommandDto({\n        pk,\n        sk,\n        id: generateId(pk, sk),\n        tenantCode,\n        code: sk,\n        type: "PRODUCT",\n        name: item.name,\n        version: VERSION_FIRST,\n        attributes: item,\n      });\n    });\n\n    const chunkResults = await Promise.all(\n      commands.map((command) =>\n        this.commandService.publishAsync(command, {\n          invokeContext: opts.invokeContext,\n        }),\n      ),\n    );\n\n    results.push(...chunkResults.map((item) => new ProductDataEntity(item)));\n  }\n\n  return results;\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"copy-operation",children:"Copy Operation"}),"\n",(0,o.jsx)(n.h3,{id:"use-case-clone-product-to-different-tenant",children:"Use Case: Clone Product to Different Tenant"}),"\n",(0,o.jsx)(n.p,{children:"Scenario: Multi-tenant SaaS where a template product needs to be copied to a new tenant."}),"\n",(0,o.jsx)(n.p,{children:"Solution: Read source entity and create new entity with different tenant's keys."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import {\n  CommandService,\n  DataService,\n  generateId,\n  IInvoke,\n  KEY_SEPARATOR,\n  VERSION_FIRST,\n} from "@mbc-cqrs-serverless/core";\nimport { NotFoundException } from "@nestjs/common";\nimport { ulid } from "ulid";\n\nasync copy(\n  sourceKey: { pk: string; sk: string },\n  targetTenantCode: string,\n  opts: { invokeContext: IInvoke },\n): Promise<ProductDataEntity> {\n  // Get source item\n  const source = await this.dataService.getItem(sourceKey);\n\n  if (!source) {\n    throw new NotFoundException("Source product not found");\n  }\n\n  // Create new keys for target tenant\n  const pk = `${PRODUCT_PK_PREFIX}${KEY_SEPARATOR}${targetTenantCode}`;\n  const sk = ulid();\n  const id = generateId(pk, sk);\n\n  // Create command with source data\n  const command = new ProductCommandDto({\n    pk,\n    sk,\n    id,\n    tenantCode: targetTenantCode,\n    code: sk,\n    type: source.type,\n    name: source.name,\n    version: VERSION_FIRST,\n    attributes: source.attributes,\n  });\n\n  const item = await this.commandService.publishAsync(command, {\n    invokeContext: opts.invokeContext,\n  });\n\n  return new ProductDataEntity(item);\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"using-history-service",children:"Using History Service"}),"\n",(0,o.jsx)(n.h3,{id:"use-case-view-previous-versions-of-a-document",children:"Use Case: View Previous Versions of a Document"}),"\n",(0,o.jsx)(n.p,{children:"Scenario: Audit requirement to show what a document looked like at a specific version."}),"\n",(0,o.jsx)(n.p,{children:"Solution: Use HistoryService to retrieve a specific version from the history table."}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'import {\n  addSortKeyVersion,\n  CommandService,\n  DataService,\n  HistoryService,\n} from "@mbc-cqrs-serverless/core";\nimport { Injectable, NotFoundException } from "@nestjs/common";\n\nimport { PrismaService } from "src/prisma";\nimport { ProductDataEntity } from "./entity/product-data.entity";\n\n@Injectable()\nexport class ProductService {\n  constructor(\n    private readonly commandService: CommandService,\n    private readonly dataService: DataService,\n    private readonly historyService: HistoryService,\n    private readonly prismaService: PrismaService,\n  ) {}\n\n  async findByVersion(\n    detailDto: { pk: string; sk: string },\n    version: number,\n  ): Promise<ProductDataEntity> {\n    // Add version to SK\n    const skWithVersion = addSortKeyVersion(detailDto.sk, version);\n\n    // Try to get from history\n    let item = await this.historyService.getItem({\n      pk: detailDto.pk,\n      sk: skWithVersion,\n    });\n\n    // Fallback to latest if not in history\n    if (!item) {\n      item = await this.dataService.getItem(detailDto);\n    }\n\n    if (!item) {\n      throw new NotFoundException("Product not found");\n    }\n\n    return new ProductDataEntity(item);\n  }\n}\n'})}),"\n",(0,o.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,o.jsx)(n.h3,{id:"1-always-use-invoke-context",children:"1. Always Use Invoke Context"}),"\n",(0,o.jsx)(n.p,{children:"Pass invoke context for audit trail:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"await this.commandService.publishAsync(command, {\n  invokeContext: opts.invokeContext,\n});\n"})}),"\n",(0,o.jsx)(n.h3,{id:"2-use-optimistic-locking",children:"2. Use Optimistic Locking"}),"\n",(0,o.jsx)(n.p,{children:"Include version in partial updates:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"const command: CommandPartialInputModel = {\n  pk: existing.pk,\n  sk: existing.sk,\n  version: existing.version, // This enables optimistic locking\n  // ...\n};\n"})}),"\n",(0,o.jsx)(n.h3,{id:"3-prefer-async-operations",children:"3. Prefer Async Operations"}),"\n",(0,o.jsx)(n.p,{children:"Use async methods for better responsiveness:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:"// Recommended: Returns immediately\nawait this.commandService.publishAsync(command, opts);\n\n// Use only when you need to wait for processing\nawait this.commandService.publishSync(command, opts);\n"})}),"\n",(0,o.jsx)(n.h3,{id:"4-combine-dynamodb-and-rds-queries",children:"4. Combine DynamoDB and RDS Queries"}),"\n",(0,o.jsx)(n.p,{children:"Use DynamoDB for single-item reads, RDS for complex queries:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-ts",children:'// Single item: Use DataService (DynamoDB)\nconst item = await this.dataService.getItem({ pk, sk });\n\n// Complex query: Use Prisma (RDS)\nconst items = await this.prismaService.product.findMany({\n  where: { category: "electronics", inStock: true },\n  orderBy: { price: "asc" },\n});\n'})})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>a});var i=t(6540);const o={},r=i.createContext(o);function s(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);