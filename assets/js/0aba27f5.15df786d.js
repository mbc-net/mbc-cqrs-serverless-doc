"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[6523],{4282:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"state-management-patterns","title":"State Management Patterns","description":"Learn how to manage state effectively in your frontend applications using Context API, axios, and Apollo Client.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/state-management-patterns.md","sourceDirName":".","slug":"/state-management-patterns","permalink":"/docs/state-management-patterns","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"description":"Learn how to manage state effectively in your frontend applications using Context API, axios, and Apollo Client."},"sidebar":"tutorialSidebar","previous":{"title":"Frontend Project Structure","permalink":"/docs/frontend-project-structure"},"next":{"title":"API Integration Patterns","permalink":"/docs/api-integration-patterns"}}');var r=t(4848),i=t(8453);const o={description:"Learn how to manage state effectively in your frontend applications using Context API, axios, and Apollo Client."},a="State Management Patterns",c={},l=[{value:"When to Use This Guide",id:"when-to-use-this-guide",level:2},{value:"Choosing the Right Tool",id:"choosing-the-right-tool",level:2},{value:"Current Implementation",id:"current-implementation",level:2},{value:"AppProviders - Centralized Service Provider",id:"appproviders---centralized-service-provider",level:3},{value:"Custom Hooks for Accessing Services",id:"custom-hooks-for-accessing-services",level:3},{value:"Context API for Client State",id:"context-api-for-client-state",level:2},{value:"Use Case: Global Loading State",id:"use-case-global-loading-state",level:3},{value:"Use Case: Custom Hook for Loading State",id:"use-case-custom-hook-for-loading-state",level:3},{value:"Use Case: Wrapping Async Actions",id:"use-case-wrapping-async-actions",level:3},{value:"axios for HTTP Requests",id:"axios-for-http-requests",level:2},{value:"Use Case: Centralized HTTP Client with Authentication",id:"use-case-centralized-http-client-with-authentication",level:3},{value:"Use Case: Making API Calls",id:"use-case-making-api-calls",level:3},{value:"Apollo Client for Real-time Subscriptions",id:"apollo-client-for-real-time-subscriptions",level:2},{value:"Use Case: GraphQL Subscriptions with AppSync",id:"use-case-graphql-subscriptions-with-appsync",level:3},{value:"Use Case: Using Subscriptions in Components",id:"use-case-using-subscriptions-in-components",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Use Context Selectively",id:"1-use-context-selectively",level:3},{value:"2. Always Handle Errors in Hooks",id:"2-always-handle-errors-in-hooks",level:3},{value:"3. Use Factory Pattern for HTTP Client",id:"3-use-factory-pattern-for-http-client",level:3},{value:"4. Clean Up Subscriptions",id:"4-clean-up-subscriptions",level:3},{value:"Alternative Options",id:"alternative-options",level:2},{value:"React Query (TanStack Query)",id:"react-query-tanstack-query",level:3},{value:"Zustand",id:"zustand",level:3},{value:"SWR",id:"swr",level:3}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"state-management-patterns",children:"State Management Patterns"})}),"\n",(0,r.jsx)(n.p,{children:"This guide explains how to manage different types of state in frontend applications. Understanding when to use each tool prevents common problems like stale data, unnecessary re-renders, and complex debugging."}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use-this-guide",children:"When to Use This Guide"}),"\n",(0,r.jsx)(n.p,{children:"Use this guide when you need to:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Cache API responses and keep them synchronized with the server"}),"\n",(0,r.jsx)(n.li,{children:"Share UI state (sidebar, theme, modals) across components"}),"\n",(0,r.jsx)(n.li,{children:"Handle loading and error states for data fetching"}),"\n",(0,r.jsx)(n.li,{children:"Implement optimistic updates for better user experience"}),"\n",(0,r.jsx)(n.li,{children:"Manage multi-tenant context in a SaaS application"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"choosing-the-right-tool",children:"Choosing the Right Tool"}),"\n",(0,r.jsx)(n.p,{children:"The most common mistake is using one tool for all state. Different types of state have different requirements:"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Category"}),(0,r.jsx)(n.th,{children:"Tool"}),(0,r.jsx)(n.th,{children:"Examples"}),(0,r.jsx)(n.th,{children:"Why This Tool"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Server State"}),(0,r.jsx)(n.td,{children:"Context API + axios"}),(0,r.jsx)(n.td,{children:"API data, loading states"}),(0,r.jsx)(n.td,{children:"Direct control over HTTP requests, simple caching strategies"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Real-time State"}),(0,r.jsx)(n.td,{children:"Apollo Client"}),(0,r.jsx)(n.td,{children:"GraphQL subscriptions, live updates"}),(0,r.jsx)(n.td,{children:"Built-in subscription support for AppSync"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Client State"}),(0,r.jsx)(n.td,{children:"Context API"}),(0,r.jsx)(n.td,{children:"UI state, user preferences"}),(0,r.jsx)(n.td,{children:"React built-in, no additional dependencies"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Form State"}),(0,r.jsx)(n.td,{children:"React Hook Form"}),(0,r.jsx)(n.td,{children:"Form inputs, validation"}),(0,r.jsx)(n.td,{children:"Optimized for form performance, built-in validation"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"URL State"}),(0,r.jsx)(n.td,{children:"Next.js Router"}),(0,r.jsx)(n.td,{children:"Query params, path params"}),(0,r.jsx)(n.td,{children:"Shareable URLs, browser history integration"})]})]})]}),"\n",(0,r.jsx)(n.h2,{id:"current-implementation",children:"Current Implementation"}),"\n",(0,r.jsx)(n.p,{children:"The MBC CQRS Serverless Web package uses the following state management architecture:"}),"\n",(0,r.jsx)(n.h3,{id:"appproviders---centralized-service-provider",children:"AppProviders - Centralized Service Provider"}),"\n",(0,r.jsx)(n.p,{children:"The application uses a centralized provider pattern that combines multiple contexts:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// provider.tsx\nimport React, { createContext, useContext, ReactNode, useMemo } from 'react'\nimport {\n  ApolloClient,\n  NormalizedCacheObject,\n  ApolloProvider,\n} from '@apollo/client'\nimport { AxiosInstance } from 'axios'\nimport { UserContext } from './types/UserContext'\n\n// Define the shape of services provided to the app\nexport interface AppServices {\n  httpClient: AxiosInstance\n  apolloClient: ApolloClient<NormalizedCacheObject>\n  user: UserContext\n  urlProvider: IUrlProvider\n}\n\n// Create context with null default for error detection\nconst AppContext = createContext<AppServices | null>(null)\n\n// Main provider that wraps the entire application\nexport function AppProviders({\n  children,\n  user,\n  httpClient,\n  apolloClient,\n  urlProvider,\n}: AppProvidersProps) {\n  const services = useMemo(() => ({\n    httpClient: httpClient ?? getClientInstance(),\n    apolloClient: apolloClient ?? apolloClientInstance,\n    urlProvider: urlProvider ?? new BaseUrlProvider(),\n    user: user,\n  }), [user, httpClient, apolloClient, urlProvider])\n\n  return (\n    <AppRootProvider services={services}>\n      <LoadingProvider>{children}</LoadingProvider>\n    </AppRootProvider>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"custom-hooks-for-accessing-services",children:"Custom Hooks for Accessing Services"}),"\n",(0,r.jsx)(n.p,{children:"Create dedicated hooks to access specific services from the context:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Hook to access the HTTP client (axios)\nexport function useHttpClient(): AxiosInstance {\n  const { httpClient } = useAppServices()\n  return httpClient\n}\n\n// Hook to access the Apollo client for GraphQL\nexport function useApolloClient(): ApolloClient<NormalizedCacheObject> {\n  const { apolloClient } = useAppServices()\n  return apolloClient\n}\n\n// Hook to access user context\nexport function useUserContext(): UserContext {\n  const { user } = useAppServices()\n  return user\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"context-api-for-client-state",children:"Context API for Client State"}),"\n",(0,r.jsx)(n.h3,{id:"use-case-global-loading-state",children:"Use Case: Global Loading State"}),"\n",(0,r.jsx)(n.p,{children:"Scenario: Show a loading overlay during async operations across the application."}),"\n",(0,r.jsx)(n.p,{children:"Problem: Each component managing its own loading state leads to inconsistent UX."}),"\n",(0,r.jsx)(n.p,{children:"Solution: Use a centralized LoadingContext that all components can access."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// stores/index.ts\nexport interface LoadingState {\n  isLoading: boolean\n  setLoading: () => void\n  closeLoading: () => void\n}\n\n// stores/provider/index.tsx\n'use client'\n\nimport React, { createContext, useState, useMemo, ReactNode } from 'react'\nimport { LoadingState } from '..'\n\nexport const LoadingContext = createContext<LoadingState>({\n  isLoading: true,\n  setLoading: () => console.warn('LoadingProvider not found'),\n  closeLoading: () => console.warn('LoadingProvider not found'),\n})\n\nLoadingContext.displayName = 'LoadingContext'\n\nexport function LoadingProvider({ children }: { children: ReactNode }) {\n  const [isLoading, setIsLoading] = useState(true)\n\n  // Memoize context value to prevent unnecessary re-renders\n  const value = useMemo(\n    () => ({\n      isLoading,\n      setLoading: () => setIsLoading(true),\n      closeLoading: () => setIsLoading(false),\n    }),\n    [isLoading]\n  )\n\n  return (\n    <LoadingContext.Provider value={value}>{children}</LoadingContext.Provider>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"use-case-custom-hook-for-loading-state",children:"Use Case: Custom Hook for Loading State"}),"\n",(0,r.jsx)(n.p,{children:"Create a custom hook with proper error handling:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// stores/hooks/index.ts\nimport React, { useContext } from 'react'\nimport { LoadingContext } from '../provider'\n\nexport function useLoadingStore() {\n  const context = useContext(LoadingContext)\n  // Safeguard: throw error if hook used outside provider\n  if (context === undefined) {\n    throw new Error('useLoading must be used within a LoadingProvider')\n  }\n  return context\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"use-case-wrapping-async-actions",children:"Use Case: Wrapping Async Actions"}),"\n",(0,r.jsx)(n.p,{children:"Scenario: Execute async functions while automatically managing the loading overlay."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// hook/useAsyncAction.ts\nimport { useLoadingStore } from '../stores/hooks'\nimport { useCallback } from 'react'\n\nexport const useAsyncAction = () => {\n  const loadingStore = useLoadingStore()\n\n  const performAction = useCallback(\n    async <T>(asyncFunction: () => Promise<T>): Promise<T> => {\n      loadingStore.setLoading()\n      try {\n        return await asyncFunction()\n      } catch (error) {\n        console.error('Async action failed:', error)\n        throw error\n      } finally {\n        loadingStore.closeLoading()\n      }\n    },\n    [loadingStore]\n  )\n\n  return { performAction, isLoading: loadingStore.isLoading }\n}\n\n// Usage in component\nfunction ProductPage() {\n  const { performAction, isLoading } = useAsyncAction()\n\n  const handleSubmit = async (data: ProductData) => {\n    await performAction(async () => {\n      await productApi.create(data)\n    })\n  }\n\n  return (\n    <form onSubmit={handleSubmit}>\n      {/* ... */}\n    </form>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"axios-for-http-requests",children:"axios for HTTP Requests"}),"\n",(0,r.jsx)(n.h3,{id:"use-case-centralized-http-client-with-authentication",children:"Use Case: Centralized HTTP Client with Authentication"}),"\n",(0,r.jsx)(n.p,{children:"Scenario: All API requests need authentication tokens and consistent error handling."}),"\n",(0,r.jsx)(n.p,{children:"Solution: Create a singleton axios instance with interceptors for token injection."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// sdk/app-client.ts\nimport axios, { AxiosInstance } from 'axios'\nimport { Auth, withSSRContext } from 'aws-amplify'\n\nexport abstract class TokenHandlerBase {\n  public constructor(protected serverSideContext?: GetServerSidePropsContext) {}\n\n  public static init(\n    serverSideContext?: GetServerSidePropsContext\n  ): TokenHandlerBase {\n    // Return test handler for Playwright tests\n    if (process.env.NEXT_PUBLIC_ENV_PLAYWRIGHT === 'true') {\n      return new TestTokenHandler(serverSideContext)\n    }\n    return new DefaultTokenHandler(serverSideContext)\n  }\n\n  public abstract getToken(): Promise<string>\n}\n\nexport class DefaultTokenHandler extends TokenHandlerBase {\n  public async getToken(): Promise<string> {\n    // Handle SSR vs client-side token retrieval\n    if (!!this.serverSideContext) {\n      const { Auth: AuthSSR } = withSSRContext({\n        req: this.serverSideContext.req,\n      })\n      return (await AuthSSR.currentSession()).getIdToken().getJwtToken()\n    } else {\n      return (await Auth.currentSession()).getIdToken().getJwtToken()\n    }\n  }\n}\n\nexport class AppClient {\n  private static instance: AxiosInstance\n\n  public static getAppClientInstance(\n    token?: string | (() => Promise<string>),\n    headers?: Record<string, string>\n  ): AxiosInstance {\n    if (!AppClient.instance) {\n      AppClient.instance = axios.create({\n        baseURL: process.env.NEXT_PUBLIC_MASTER_API_BASE,\n        timeout: 0,\n        headers: { ...headers },\n      })\n    }\n    // Add interceptor to inject auth token\n    AppClient.instance.interceptors.request.use(\n      async (config) => {\n        let tokenString = ''\n        if (token) {\n          tokenString = typeof token === 'string' ? token : await token()\n        }\n        config.headers.Authorization = `Bearer ${tokenString}`\n        return config\n      },\n      (error) => Promise.reject(error)\n    )\n    return AppClient.instance\n  }\n}\n\n// Factory function for creating authenticated client\nexport const getClientInstance = (headers?: Record<string, string>) => {\n  const tokenHandler = TokenHandlerBase.init()\n\n  const token = () =>\n    tokenHandler\n      .getToken()\n      .then((token) => token)\n      .catch((err) => {\n        const error = new UnauthorizedException(\n          null,\n          err,\n          'Failed to get access token. Session expired.'\n        )\n        return Promise.reject(error)\n      })\n  return AppClient.getAppClientInstance(token, headers)\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"use-case-making-api-calls",children:"Use Case: Making API Calls"}),"\n",(0,r.jsx)(n.p,{children:"Using the HTTP client through the context hook:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { useHttpClient } from '@mbc-cqrs-serverless/master-web/AppProviders'\n\nfunction ProductList() {\n  const httpClient = useHttpClient()\n  const [products, setProducts] = useState<Product[]>([])\n  const [loading, setLoading] = useState(false)\n\n  const fetchProducts = async () => {\n    setLoading(true)\n    try {\n      const response = await httpClient.get('/products')\n      setProducts(response.data)\n    } catch (error) {\n      console.error('Failed to fetch products:', error)\n    } finally {\n      setLoading(false)\n    }\n  }\n\n  useEffect(() => {\n    fetchProducts()\n  }, [])\n\n  return (\n    <div>\n      {loading ? <Spinner /> : products.map(p => <ProductCard key={p.id} product={p} />)}\n    </div>\n  )\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"apollo-client-for-real-time-subscriptions",children:"Apollo Client for Real-time Subscriptions"}),"\n",(0,r.jsx)(n.h3,{id:"use-case-graphql-subscriptions-with-appsync",children:"Use Case: GraphQL Subscriptions with AppSync"}),"\n",(0,r.jsx)(n.p,{children:"Scenario: Display real-time command status updates (e.g., data sync progress)."}),"\n",(0,r.jsx)(n.p,{children:"Solution: Use Apollo Client's subscription feature connected to AWS AppSync."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// appsync/subscribe.ts\nimport { gql, ApolloClient, NormalizedCacheObject } from '@apollo/client'\nimport {\n  OnMessageSubscription,\n  OnMessageSubscriptionVariables,\n} from './API'\nimport { onMessage } from './graphql/subscriptions'\n\nexport type CommandStatusContent = {\n  status:\n    | 'finish:FINISHED'\n    | 'finish:STARTED'\n    | 'sync_data:FINISHED'\n    | 'sync_data:STARTED'\n    | 'transform_data:FINISHED'\n    | 'transform_data:STARTED'\n}\n\nexport type DecodedMessage = Omit<Message, 'content'> & {\n  content: MessageContent\n}\n\nexport function subscribeMessage(\n  client: ApolloClient<NormalizedCacheObject>,\n  filters: OnMessageSubscriptionVariables,\n  handler: (value: DecodedMessage) => void | Promise<void>\n) {\n  const observable = client.subscribe<\n    OnMessageSubscription,\n    OnMessageSubscriptionVariables\n  >({\n    query: gql`\n      ${onMessage}\n    `,\n    variables: filters,\n  })\n\n  return observable.subscribe({\n    next: ({ data }) => {\n      if (!data.onMessage) {\n        return\n      }\n      const message: DecodedMessage = {\n        ...data.onMessage,\n        content: parseContent(data.onMessage.content),\n      }\n      if (message) {\n        handler(message)\n      }\n    },\n    error: (error) => console.error('subscribeMessage error:', error),\n  })\n}\n\nfunction parseContent(content: string): MessageContent {\n  try {\n    return JSON.parse(content)\n  } catch (error) {\n    return content\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"use-case-using-subscriptions-in-components",children:"Use Case: Using Subscriptions in Components"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { useApolloClient } from '@mbc-cqrs-serverless/master-web/AppProviders'\nimport { subscribeMessage, DecodedMessage } from '../appsync/subscribe'\nimport { useEffect, useState } from 'react'\n\nfunction CommandStatusDisplay({ commandId }: { commandId: string }) {\n  const apolloClient = useApolloClient()\n  const [status, setStatus] = useState<string>('pending')\n\n  useEffect(() => {\n    const subscription = subscribeMessage(\n      apolloClient,\n      { pk: commandId },\n      (message: DecodedMessage) => {\n        if (typeof message.content === 'object') {\n          setStatus(message.content.status)\n        }\n      }\n    )\n\n    // Cleanup subscription on unmount\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [apolloClient, commandId])\n\n  return <StatusBadge status={status} />\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-use-context-selectively",children:"1. Use Context Selectively"}),"\n",(0,r.jsx)(n.p,{children:"Problem: Putting too much state in a single context causes unnecessary re-renders."}),"\n",(0,r.jsx)(n.p,{children:"Solution: Split contexts by domain and use memoization."}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Good: Separate contexts for different concerns\n<AuthProvider>\n  <UIProvider>\n    <LoadingProvider>\n      {children}\n    </LoadingProvider>\n  </UIProvider>\n</AuthProvider>\n\n// Good: Memoize context values\nconst value = useMemo(\n  () => ({ isLoading, setLoading, closeLoading }),\n  [isLoading]\n)\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-always-handle-errors-in-hooks",children:"2. Always Handle Errors in Hooks"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"export function useAppServices(): AppServices {\n  const context = useContext(AppContext)\n  // Throw helpful error if context is missing\n  if (context === null) {\n    throw new Error('useAppServices must be used within an AppRootProvider')\n  }\n  return context\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-use-factory-pattern-for-http-client",children:"3. Use Factory Pattern for HTTP Client"}),"\n",(0,r.jsx)(n.p,{children:"This allows for different configurations in different environments:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Production: Real auth tokens\nconst client = getClientInstance()\n\n// Testing: Mock tokens\nclass TestTokenHandler extends TokenHandlerBase {\n  public async getToken(): Promise<string> {\n    return 'test'\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"4-clean-up-subscriptions",children:"4. Clean Up Subscriptions"}),"\n",(0,r.jsx)(n.p,{children:"Always unsubscribe from Apollo subscriptions to prevent memory leaks:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"useEffect(() => {\n  const subscription = subscribeMessage(client, filters, handler)\n\n  return () => {\n    subscription.unsubscribe()\n  }\n}, [client, filters])\n"})}),"\n",(0,r.jsx)(n.h2,{id:"alternative-options",children:"Alternative Options"}),"\n",(0,r.jsx)(n.p,{children:"While the current implementation uses Context API with axios and Apollo Client, there are alternative state management solutions you may consider for specific use cases:"}),"\n",(0,r.jsx)(n.h3,{id:"react-query-tanstack-query",children:"React Query (TanStack Query)"}),"\n",(0,r.jsx)(n.p,{children:"Best for applications with complex server state caching requirements:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Automatic background refetching"}),"\n",(0,r.jsx)(n.li,{children:"Cache invalidation and synchronization"}),"\n",(0,r.jsx)(n.li,{children:"Optimistic updates"}),"\n",(0,r.jsx)(n.li,{children:"Infinite scroll and pagination"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Example: React Query usage\nimport { useQuery, useMutation, useQueryClient } from '@tanstack/react-query'\n\nexport function useProducts() {\n  return useQuery({\n    queryKey: ['products'],\n    queryFn: () => productApi.list(),\n  })\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"zustand",children:"Zustand"}),"\n",(0,r.jsx)(n.p,{children:"Best for applications needing lightweight global state without Context boilerplate:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Simple API with selectors"}),"\n",(0,r.jsx)(n.li,{children:"Persist middleware for localStorage"}),"\n",(0,r.jsx)(n.li,{children:"DevTools integration"}),"\n",(0,r.jsx)(n.li,{children:"No provider required"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Example: Zustand store\nimport { create } from 'zustand'\n\ninterface UIState {\n  sidebarOpen: boolean\n  toggleSidebar: () => void\n}\n\nexport const useUIStore = create<UIState>((set) => ({\n  sidebarOpen: true,\n  toggleSidebar: () => set((state) => ({ sidebarOpen: !state.sidebarOpen })),\n}))\n"})}),"\n",(0,r.jsx)(n.h3,{id:"swr",children:"SWR"}),"\n",(0,r.jsx)(n.p,{children:"Best for simple data fetching with automatic revalidation:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Stale-while-revalidate strategy"}),"\n",(0,r.jsx)(n.li,{children:"Focus revalidation"}),"\n",(0,r.jsx)(n.li,{children:"Polling support"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Example: SWR usage\nimport useSWR from 'swr'\n\nfunction Profile() {\n  const { data, error, isLoading } = useSWR('/api/user', fetcher)\n\n  if (isLoading) return <Spinner />\n  if (error) return <Error />\n  return <div>Hello, {data.name}</div>\n}\n"})}),"\n",(0,r.jsx)(n.p,{children:"Choose the right tool based on your project's complexity and requirements. The current implementation with Context API + axios + Apollo Client provides a solid foundation that can be extended as needed."})]})}function p(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var s=t(6540);const r={},i=s.createContext(r);function o(e){const n=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),s.createElement(i.Provider,{value:n},e.children)}}}]);