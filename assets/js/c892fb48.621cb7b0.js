"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[4095],{6473:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});const i=JSON.parse('{"id":"version-conflict-guide","title":"Version Conflict Guide","description":"Learn how to handle version conflicts and implement concurrency control strategies","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/version-conflict-guide.md","sourceDirName":".","slug":"/version-conflict-guide","permalink":"/docs/version-conflict-guide","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6,"description":"Learn how to handle version conflicts and implement concurrency control strategies"},"sidebar":"tutorialSidebar","previous":{"title":"Entity Definition Patterns","permalink":"/docs/entity-patterns"},"next":{"title":"Backend Development Guide","permalink":"/docs/backend-development"}}');var r=t(4848),s=t(8453);const o={sidebar_position:6,description:"Learn how to handle version conflicts and implement concurrency control strategies"},a="Version Conflict Guide",c={},l=[{value:"What Causes Version Conflicts",id:"what-causes-version-conflicts",level:2},{value:"Conflict Scenario",id:"conflict-scenario",level:3},{value:"How Optimistic Locking Works",id:"how-optimistic-locking-works",level:2},{value:"Version Constants",id:"version-constants",level:3},{value:"How It Works Internally",id:"how-it-works-internally",level:3},{value:"Prevention Strategies",id:"prevention-strategies",level:2},{value:"1. Always Include Version in Updates",id:"1-always-include-version-in-updates",level:3},{value:"2. Use VERSION_LATEST for Auto-Resolution",id:"2-use-version_latest-for-auto-resolution",level:3},{value:"3. Use VERSION_FIRST for New Items",id:"3-use-version_first-for-new-items",level:3},{value:"Recovery Patterns",id:"recovery-patterns",level:2},{value:"Basic Retry Logic",id:"basic-retry-logic",level:3},{value:"Exponential Backoff Pattern",id:"exponential-backoff-pattern",level:3},{value:"Handling Conflicts in Controllers",id:"handling-conflicts-in-controllers",level:3},{value:"When to Use VERSION_FIRST vs VERSION_LATEST",id:"when-to-use-version_first-vs-version_latest",level:2},{value:"VERSION_FIRST (0)",id:"version_first-0",level:3},{value:"VERSION_LATEST (-1)",id:"version_latest--1",level:3},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Design for Concurrency",id:"1-design-for-concurrency",level:3},{value:"2. Handle Conflicts Gracefully",id:"2-handle-conflicts-gracefully",level:3},{value:"3. Use Appropriate Version Strategy",id:"3-use-appropriate-version-strategy",level:3},{value:"4. Client-Side Considerations",id:"4-client-side-considerations",level:3},{value:"5. Monitoring and Alerting",id:"5-monitoring-and-alerting",level:3},{value:"Related Documentation",id:"related-documentation",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,s.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"version-conflict-guide",children:"Version Conflict Guide"})}),"\n",(0,r.jsx)(n.p,{children:"This guide explains how version conflicts occur in the MBC CQRS Serverless Framework and provides strategies for prevention and recovery."}),"\n",(0,r.jsx)(n.h2,{id:"what-causes-version-conflicts",children:"What Causes Version Conflicts"}),"\n",(0,r.jsx)(n.p,{children:"Version conflicts occur when two or more operations attempt to update the same item simultaneously. In a distributed system like serverless applications, this is a common scenario that must be handled properly."}),"\n",(0,r.jsx)(n.h3,{id:"conflict-scenario",children:"Conflict Scenario"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"User A reads item (version 1)\nUser B reads item (version 1)\nUser A updates item (version 1 -> 2) - Success\nUser B updates item (version 1 -> 2) - CONFLICT!\n"})}),"\n",(0,r.jsx)(n.p,{children:"In this scenario, User B's update fails because the item has already been updated by User A. The framework uses DynamoDB's conditional writes to detect this situation."}),"\n",(0,r.jsx)(n.h2,{id:"how-optimistic-locking-works",children:"How Optimistic Locking Works"}),"\n",(0,r.jsxs)(n.p,{children:["The framework implements optimistic locking through the ",(0,r.jsx)(n.code,{children:"version"})," field on each item. This approach assumes conflicts are rare and handles them when they occur, rather than locking resources preemptively."]}),"\n",(0,r.jsx)(n.h3,{id:"version-constants",children:"Version Constants"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { VERSION_FIRST, VERSION_LATEST } from '@mbc-cqrs-serverless/core';\n\n// VERSION_FIRST = 0: Used when creating new items\n// VERSION_LATEST = -1: Auto-resolve to the latest version\n"})}),"\n",(0,r.jsx)(n.h3,{id:"how-it-works-internally",children:"How It Works Internally"}),"\n",(0,r.jsx)(n.p,{children:"When publishing a command, the framework:"}),"\n",(0,r.jsxs)(n.ol,{children:["\n",(0,r.jsx)(n.li,{children:"Checks the input version against the current item's version"}),"\n",(0,r.jsx)(n.li,{children:"Increments the version number by 1"}),"\n",(0,r.jsxs)(n.li,{children:["Uses DynamoDB conditional expression ",(0,r.jsx)(n.code,{children:"attribute_not_exists(pk) AND attribute_not_exists(sk)"})," to ensure uniqueness"]}),"\n",(0,r.jsxs)(n.li,{children:["If another update occurred first, DynamoDB throws ",(0,r.jsx)(n.code,{children:"ConditionalCheckFailedException"})]}),"\n",(0,r.jsx)(n.li,{children:"The framework converts this to HTTP 409 Conflict response"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Internal implementation (simplified)\nawait this.dynamoDbService.putItem(\n  this.tableName,\n  command,\n  'attribute_not_exists(pk) AND attribute_not_exists(sk)', // Conditional write\n);\n"})}),"\n",(0,r.jsx)(n.h2,{id:"prevention-strategies",children:"Prevention Strategies"}),"\n",(0,r.jsx)(n.h3,{id:"1-always-include-version-in-updates",children:"1. Always Include Version in Updates"}),"\n",(0,r.jsx)(n.p,{children:"When updating an item, always include the current version number:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { CommandPartialInputModel } from '@mbc-cqrs-serverless/core';\n\n// First, get the current item to know its version\nconst currentItem = await this.dataService.getItem({ pk, sk });\n\nconst updateCommand: CommandPartialInputModel = {\n  pk: currentItem.pk,\n  sk: currentItem.sk,\n  version: currentItem.version, // Include current version\n  name: 'Updated Name',\n};\n\nawait this.commandService.publishPartialUpdateAsync(updateCommand, {\n  source: 'updateItem',\n  invokeContext,\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"2-use-version_latest-for-auto-resolution",children:"2. Use VERSION_LATEST for Auto-Resolution"}),"\n",(0,r.jsx)(n.p,{children:"When you want to always update the latest version without worrying about the exact version number:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { VERSION_LATEST, CommandInputModel } from '@mbc-cqrs-serverless/core';\n\nconst command: CommandInputModel = {\n  pk: catPk,\n  sk: catSk,\n  id: generateId(catPk, catSk),\n  code,\n  type: 'CAT',\n  name: 'Updated Name',\n  version: VERSION_LATEST, // Auto-resolve to latest version\n  attributes,\n};\n\nawait this.commandService.publishAsync(command, {\n  source: 'updateCat',\n  invokeContext,\n});\n"})}),"\n",(0,r.jsx)(n.h3,{id:"3-use-version_first-for-new-items",children:"3. Use VERSION_FIRST for New Items"}),"\n",(0,r.jsx)(n.p,{children:"When creating new items, use VERSION_FIRST (0) to indicate this is the first version:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { VERSION_FIRST, CommandDto } from '@mbc-cqrs-serverless/core';\n\nconst newCatCommand = new CatCommandDto({\n  pk: catPk,\n  sk: catSk,\n  id: generateId(catPk, catSk),\n  code,\n  type: 'CAT',\n  name: 'New Cat',\n  version: VERSION_FIRST, // 0 - indicates new item\n  attributes,\n});\n\nawait this.commandService.publishAsync(newCatCommand, {\n  source: 'createCat',\n  invokeContext,\n});\n"})}),"\n",(0,r.jsx)(n.h2,{id:"recovery-patterns",children:"Recovery Patterns"}),"\n",(0,r.jsx)(n.h3,{id:"basic-retry-logic",children:"Basic Retry Logic"}),"\n",(0,r.jsx)(n.p,{children:"Implement retry logic to handle transient conflicts:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import { ConditionalCheckFailedException } from '@aws-sdk/client-dynamodb';\n\nasync function updateWithRetry(\n  commandService: CommandService,\n  dataService: DataService,\n  pk: string,\n  sk: string,\n  updateData: Partial<CommandInputModel>,\n  invokeContext: IInvoke,\n  maxRetries = 3,\n): Promise<CommandModel> {\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      // Get latest version\n      const currentItem = await dataService.getItem({ pk, sk });\n\n      const command: CommandPartialInputModel = {\n        pk,\n        sk,\n        version: currentItem?.version || VERSION_FIRST,\n        ...updateData,\n      };\n\n      return await commandService.publishPartialUpdateAsync(command, {\n        source: 'updateWithRetry',\n        invokeContext,\n      });\n    } catch (error) {\n      if (\n        error instanceof ConditionalCheckFailedException ||\n        error.statusCode === 409\n      ) {\n        if (attempt === maxRetries) {\n          throw new Error(\n            `Failed to update after ${maxRetries} attempts due to version conflicts`,\n          );\n        }\n        // Wait before retry (exponential backoff)\n        await new Promise((resolve) =>\n          setTimeout(resolve, Math.pow(2, attempt) * 100),\n        );\n        continue;\n      }\n      throw error;\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"exponential-backoff-pattern",children:"Exponential Backoff Pattern"}),"\n",(0,r.jsx)(n.p,{children:"For high-contention scenarios, use exponential backoff with jitter:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"async function exponentialBackoff(attempt: number): Promise<void> {\n  const baseDelay = 100; // Base delay in milliseconds\n  const maxDelay = 5000; // Maximum delay\n\n  // Calculate delay with exponential backoff\n  const delay = Math.min(baseDelay * Math.pow(2, attempt), maxDelay);\n\n  // Add random jitter to prevent thundering herd\n  const jitter = Math.random() * delay * 0.1;\n\n  await new Promise((resolve) => setTimeout(resolve, delay + jitter));\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"handling-conflicts-in-controllers",children:"Handling Conflicts in Controllers"}),"\n",(0,r.jsx)(n.p,{children:"Handle version conflicts gracefully in your API controllers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"import {\n  Controller,\n  Put,\n  Body,\n  Param,\n  HttpException,\n  HttpStatus,\n} from '@nestjs/common';\n\n@Controller('cats')\nexport class CatController {\n  constructor(private readonly catService: CatService) {}\n\n  @Put(':id')\n  async updateCat(\n    @Param('id') id: string,\n    @Body() updateDto: UpdateCatDto,\n    @InvokeContext() invokeContext: IInvoke,\n  ) {\n    try {\n      return await this.catService.update(id, updateDto, invokeContext);\n    } catch (error) {\n      if (error.statusCode === 409) {\n        throw new HttpException(\n          {\n            statusCode: HttpStatus.CONFLICT,\n            message: 'Version conflict. Please refresh and try again.',\n            error: 'Conflict',\n          },\n          HttpStatus.CONFLICT,\n        );\n      }\n      throw error;\n    }\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h2,{id:"when-to-use-version_first-vs-version_latest",children:"When to Use VERSION_FIRST vs VERSION_LATEST"}),"\n",(0,r.jsxs)(n.table,{children:[(0,r.jsx)(n.thead,{children:(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.th,{children:"Scenario"}),(0,r.jsx)(n.th,{children:"Use"}),(0,r.jsx)(n.th,{children:"Reason"})]})}),(0,r.jsxs)(n.tbody,{children:[(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Creating new item"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"VERSION_FIRST"})," (0)"]}),(0,r.jsx)(n.td,{children:"Indicates this is the first version of the item"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Updating with known version"}),(0,r.jsx)(n.td,{children:"Actual version number"}),(0,r.jsx)(n.td,{children:"Ensures you're updating the expected version"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Updating to latest (no conflict check)"}),(0,r.jsxs)(n.td,{children:[(0,r.jsx)(n.code,{children:"VERSION_LATEST"})," (-1)"]}),(0,r.jsx)(n.td,{children:"Auto-resolves to latest, but may overwrite concurrent changes"})]}),(0,r.jsxs)(n.tr,{children:[(0,r.jsx)(n.td,{children:"Partial update"}),(0,r.jsx)(n.td,{children:"Current item's version"}),(0,r.jsx)(n.td,{children:"Ensures update is based on current state"})]})]})]}),"\n",(0,r.jsx)(n.h3,{id:"version_first-0",children:"VERSION_FIRST (0)"}),"\n",(0,r.jsx)(n.p,{children:"Use when:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Creating a new item that doesn't exist yet"}),"\n",(0,r.jsx)(n.li,{children:"The item should have version 1 after creation"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const newCommand = {\n  pk: 'CAT#tenant1',\n  sk: 'cat#001',\n  version: VERSION_FIRST, // version 0\n  // ... other fields\n};\n"})}),"\n",(0,r.jsx)(n.h3,{id:"version_latest--1",children:"VERSION_LATEST (-1)"}),"\n",(0,r.jsx)(n.p,{children:"Use when:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"You want to update regardless of current version"}),"\n",(0,r.jsx)(n.li,{children:"Conflicts are acceptable and the latest data should win"}),"\n",(0,r.jsx)(n.li,{children:'Implementing "last writer wins" semantics'}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"const updateCommand = {\n  pk: 'CAT#tenant1',\n  sk: 'cat#001',\n  version: VERSION_LATEST, // -1, auto-resolves\n  // ... other fields\n};\n"})}),"\n",(0,r.jsx)(n.admonition,{title:"Caution with VERSION_LATEST",type:"warning",children:(0,r.jsxs)(n.p,{children:["Using ",(0,r.jsx)(n.code,{children:"VERSION_LATEST"})," bypasses conflict detection. Only use it when you intentionally want to overwrite any concurrent changes. For most use cases, you should use the actual version number from the current item."]})}),"\n",(0,r.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,r.jsx)(n.h3,{id:"1-design-for-concurrency",children:"1. Design for Concurrency"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Keep transactions short and focused"}),"\n",(0,r.jsx)(n.li,{children:"Minimize the time between reading and writing"}),"\n",(0,r.jsx)(n.li,{children:"Avoid long-running operations between read and update"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"2-handle-conflicts-gracefully",children:"2. Handle Conflicts Gracefully"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Always catch and handle version conflict errors"}),"\n",(0,r.jsx)(n.li,{children:"Provide clear error messages to users"}),"\n",(0,r.jsx)(n.li,{children:"Implement appropriate retry strategies"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"3-use-appropriate-version-strategy",children:"3. Use Appropriate Version Strategy"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Use explicit version numbers for strict concurrency control"}),"\n",(0,r.jsx)(n.li,{children:'Use VERSION_LATEST only when "last writer wins" is acceptable'}),"\n",(0,r.jsx)(n.li,{children:"Always validate version in partial updates"}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"4-client-side-considerations",children:"4. Client-Side Considerations"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Store the version number when fetching data"}),"\n",(0,r.jsx)(n.li,{children:"Include version in update requests"}),"\n",(0,r.jsx)(n.li,{children:"Handle 409 Conflict responses by refreshing data and retrying"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-typescript",children:"// Frontend example\nasync function updateItem(item, changes) {\n  try {\n    const response = await fetch(`/api/items/${item.id}`, {\n      method: 'PUT',\n      body: JSON.stringify({\n        ...changes,\n        version: item.version, // Include version\n      }),\n    });\n\n    if (response.status === 409) {\n      // Handle conflict - refresh and show user the changes\n      const latestItem = await fetchItem(item.id);\n      throw new ConflictError('Item was modified. Please review changes.', latestItem);\n    }\n\n    return response.json();\n  } catch (error) {\n    // Handle other errors\n    throw error;\n  }\n}\n"})}),"\n",(0,r.jsx)(n.h3,{id:"5-monitoring-and-alerting",children:"5. Monitoring and Alerting"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"Monitor conflict rates in your application"}),"\n",(0,r.jsx)(n.li,{children:"High conflict rates may indicate design issues"}),"\n",(0,r.jsx)(n.li,{children:"Consider restructuring data or reducing contention"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"related-documentation",children:"Related Documentation"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/version-rules",children:"Versioning Rules"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/command-service",children:"CommandService"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.a,{href:"/docs/error-catalog",children:"Error Catalog"})}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>a});var i=t(6540);const r={},s=i.createContext(r);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);