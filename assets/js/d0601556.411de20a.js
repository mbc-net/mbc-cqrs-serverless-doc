"use strict";(self.webpackChunkdoc=self.webpackChunkdoc||[]).push([[2582],{1410:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>m,frontMatter:()=>d,metadata:()=>r,toc:()=>c});const r=JSON.parse('{"id":"data-sync-handler-examples","title":"Data Sync Handler Examples","description":"Practical examples of implementing Data Sync Handlers for various use cases.","source":"@site/i18n/en/docusaurus-plugin-content-docs/current/data-sync-handler-examples.md","sourceDirName":".","slug":"/data-sync-handler-examples","permalink":"/docs/data-sync-handler-examples","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{"description":"Practical examples of implementing Data Sync Handlers for various use cases."},"sidebar":"tutorialSidebar","previous":{"title":"Event Handling Patterns","permalink":"/docs/event-handling-patterns"},"next":{"title":"Service Implementation Patterns","permalink":"/docs/service-patterns"}}');var s=t(4848),a=t(8453);const d={description:"Practical examples of implementing Data Sync Handlers for various use cases."},i="Data Sync Handler Examples",o={},c=[{value:"When to Use This Guide",id:"when-to-use-this-guide",level:2},{value:"Problems This Pattern Solves",id:"problems-this-pattern-solves",level:2},{value:"Basic Structure",id:"basic-structure",level:2},{value:"Example 1: Simple Entity Sync",id:"example-1-simple-entity-sync",level:2},{value:"Use Case: Sync Products to Enable Search and Filtering",id:"use-case-sync-products-to-enable-search-and-filtering",level:3},{value:"Example 2: Conditional Processing with SK Prefix",id:"example-2-conditional-processing-with-sk-prefix",level:2},{value:"Use Case: Order and OrderItem in Same DynamoDB Table",id:"use-case-order-and-orderitem-in-same-dynamodb-table",level:3},{value:"Example 3: Complex Attribute Transformation",id:"example-3-complex-attribute-transformation",level:2},{value:"Use Case: Notifications with Different Content Types",id:"use-case-notifications-with-different-content-types",level:3},{value:"Example 4: PK Prefix Filtering",id:"example-4-pk-prefix-filtering",level:2},{value:"Use Case: User Records in Shared Table",id:"use-case-user-records-in-shared-table",level:3},{value:"Example 5: Parsing SK for Derived Data",id:"example-5-parsing-sk-for-derived-data",level:2},{value:"Use Case: Master Data with Category Information in SK",id:"use-case-master-data-with-category-information-in-sk",level:3},{value:"Registering Multiple Handlers",id:"registering-multiple-handlers",level:2},{value:"Best Practices",id:"best-practices",level:2},{value:"1. Always Remove Version from SK",id:"1-always-remove-version-from-sk",level:3},{value:"2. Handle undefined isDeleted",id:"2-handle-undefined-isdeleted",level:3},{value:"3. Store Both Original and Cleaned Keys",id:"3-store-both-original-and-cleaned-keys",level:3},{value:"4. Type Your Attributes",id:"4-type-your-attributes",level:3},{value:"5. Handle Null/Undefined Gracefully",id:"5-handle-nullundefined-gracefully",level:3}];function l(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"data-sync-handler-examples",children:"Data Sync Handler Examples"})}),"\n",(0,s.jsx)(n.p,{children:"This guide explains how to implement Data Sync Handlers that automatically synchronize data from DynamoDB (command source) to RDS (query database). This is the core mechanism that enables the CQRS read model."}),"\n",(0,s.jsx)(n.h2,{id:"when-to-use-this-guide",children:"When to Use This Guide"}),"\n",(0,s.jsx)(n.p,{children:"Use this guide when you need to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Sync entity data from DynamoDB to MySQL/PostgreSQL for complex queries"}),"\n",(0,s.jsx)(n.li,{children:"Transform nested JSON attributes into relational columns"}),"\n",(0,s.jsx)(n.li,{children:"Handle different record types within the same DynamoDB table"}),"\n",(0,s.jsx)(n.li,{children:"Process parent-child relationships (Order, OrderItem) separately"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"problems-this-pattern-solves",children:"Problems This Pattern Solves"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Problem"}),(0,s.jsx)(n.th,{children:"Solution"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"DynamoDB cannot do JOINs or complex filters"}),(0,s.jsx)(n.td,{children:"Sync data to RDS for SQL queries"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Version suffix in SK causes duplicate records"}),(0,s.jsx)(n.td,{children:"Use removeSortKeyVersion() before upserting"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Different record types need different RDS tables"}),(0,s.jsx)(n.td,{children:"Filter by SK prefix in handler"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"JSON attributes need to be searchable columns"}),(0,s.jsx)(n.td,{children:"Map attributes to individual RDS columns"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"basic-structure",children:"Basic Structure"}),"\n",(0,s.jsx)(n.p,{children:"All Data Sync Handlers follow this basic structure:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { CommandModel, IDataSyncHandler, removeSortKeyVersion } from "@mbc-cqrs-serverless/core";\nimport { Injectable, Logger } from "@nestjs/common";\nimport { PrismaService } from "src/prisma";\n\n@Injectable()\nexport class EntityDataSyncRdsHandler implements IDataSyncHandler {\n  private readonly logger = new Logger(EntityDataSyncRdsHandler.name);\n\n  constructor(private readonly prismaService: PrismaService) {}\n\n  async up(cmd: CommandModel): Promise<any> {\n    // Sync data to RDS\n  }\n\n  async down(cmd: CommandModel): Promise<any> {\n    // Optional: Handle rollback (usually just logs)\n    this.logger.debug(cmd);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"example-1-simple-entity-sync",children:"Example 1: Simple Entity Sync"}),"\n",(0,s.jsx)(n.h3,{id:"use-case-sync-products-to-enable-search-and-filtering",children:"Use Case: Sync Products to Enable Search and Filtering"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: Products stored in DynamoDB need to be searchable by category, price range, and text."}),"\n",(0,s.jsx)(n.p,{children:"Solution: Sync to RDS and map attributes to indexed columns for efficient queries."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import {\n  CommandModel,\n  IDataSyncHandler,\n  removeSortKeyVersion\n} from "@mbc-cqrs-serverless/core";\nimport { Injectable, Logger } from "@nestjs/common";\nimport { PrismaService } from "src/prisma";\n\ninterface ProductAttributes {\n  name: string;\n  description: string;\n  price: number;\n  category: string;\n  inStock: boolean;\n}\n\n@Injectable()\nexport class ProductDataSyncRdsHandler implements IDataSyncHandler {\n  private readonly logger = new Logger(ProductDataSyncRdsHandler.name);\n\n  constructor(private readonly prismaService: PrismaService) {}\n\n  async up(cmd: CommandModel): Promise<any> {\n    // Remove version suffix from sort key (e.g., "PROD001@1" -> "PROD001")\n    const sk = removeSortKeyVersion(cmd.sk);\n    const attrs = cmd.attributes as ProductAttributes;\n\n    await this.prismaService.product.upsert({\n      where: { id: cmd.id },\n      update: {\n        pk: cmd.pk,\n        sk: sk,\n        name: cmd.name,\n        code: cmd.code,\n        version: cmd.version,\n        tenantCode: cmd.tenantCode,\n        // Map attributes to columns\n        description: attrs.description,\n        price: attrs.price,\n        category: attrs.category,\n        inStock: attrs.inStock,\n        // Audit fields\n        isDeleted: cmd.isDeleted ?? false,\n        createdAt: cmd.createdAt,\n        createdBy: cmd.createdBy,\n        updatedAt: cmd.updatedAt,\n        updatedBy: cmd.updatedBy,\n      },\n      create: {\n        id: cmd.id,\n        pk: cmd.pk,\n        sk: sk,\n        // Also store original keys with version for reference\n        cpk: cmd.pk,\n        csk: cmd.sk,\n        name: cmd.name,\n        code: cmd.code,\n        version: cmd.version,\n        tenantCode: cmd.tenantCode,\n        description: attrs.description,\n        price: attrs.price,\n        category: attrs.category,\n        inStock: attrs.inStock,\n        isDeleted: cmd.isDeleted ?? false,\n        createdAt: cmd.createdAt,\n        createdBy: cmd.createdBy,\n        updatedAt: cmd.updatedAt,\n        updatedBy: cmd.updatedBy,\n      },\n    });\n  }\n\n  async down(cmd: CommandModel): Promise<any> {\n    this.logger.debug(cmd);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"example-2-conditional-processing-with-sk-prefix",children:"Example 2: Conditional Processing with SK Prefix"}),"\n",(0,s.jsx)(n.h3,{id:"use-case-order-and-orderitem-in-same-dynamodb-table",children:"Use Case: Order and OrderItem in Same DynamoDB Table"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: Orders and their items share the same PK but have different SK prefixes. Each needs to go to a different RDS table."}),"\n",(0,s.jsx)(n.p,{children:"Solution: Check SK prefix to route to appropriate sync logic."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import {\n  CommandModel,\n  IDataSyncHandler,\n  KEY_SEPARATOR,\n  removeSortKeyVersion\n} from "@mbc-cqrs-serverless/core";\nimport { Injectable, Logger } from "@nestjs/common";\nimport { PrismaService } from "src/prisma";\n\nconst ORDER_SK_PREFIX = "ORDER";\nconst ORDER_ITEM_SK_PREFIX = "ORDER_ITEM";\n\ninterface OrderAttributes {\n  customerId: string;\n  status: string;\n  totalAmount: number;\n  orderDate: string;\n}\n\ninterface OrderItemAttributes {\n  orderId: string;\n  productId: string;\n  quantity: number;\n  unitPrice: number;\n}\n\n@Injectable()\nexport class OrderDataSyncRdsHandler implements IDataSyncHandler {\n  private readonly logger = new Logger(OrderDataSyncRdsHandler.name);\n\n  constructor(private readonly prismaService: PrismaService) {}\n\n  async up(cmd: CommandModel): Promise<any> {\n    const sk = removeSortKeyVersion(cmd.sk);\n\n    // Process only ORDER records, skip ORDER_ITEM\n    if (sk.startsWith(ORDER_SK_PREFIX) && !sk.startsWith(ORDER_ITEM_SK_PREFIX)) {\n      await this.syncOrder(cmd, sk);\n    } else if (sk.startsWith(ORDER_ITEM_SK_PREFIX)) {\n      await this.syncOrderItem(cmd, sk);\n    }\n    // Skip other record types\n  }\n\n  private async syncOrder(cmd: CommandModel, sk: string): Promise<void> {\n    const attrs = cmd.attributes as OrderAttributes;\n\n    await this.prismaService.order.upsert({\n      where: { id: cmd.id },\n      update: {\n        pk: cmd.pk,\n        sk: sk,\n        code: cmd.code,\n        version: cmd.version,\n        customerId: attrs.customerId,\n        status: attrs.status,\n        totalAmount: attrs.totalAmount,\n        orderDate: new Date(attrs.orderDate),\n        isDeleted: cmd.isDeleted ?? false,\n        updatedAt: cmd.updatedAt,\n        updatedBy: cmd.updatedBy,\n      },\n      create: {\n        id: cmd.id,\n        pk: cmd.pk,\n        sk: sk,\n        cpk: cmd.pk,\n        csk: cmd.sk,\n        code: cmd.code,\n        version: cmd.version,\n        tenantCode: cmd.tenantCode,\n        customerId: attrs.customerId,\n        status: attrs.status,\n        totalAmount: attrs.totalAmount,\n        orderDate: new Date(attrs.orderDate),\n        isDeleted: cmd.isDeleted ?? false,\n        createdAt: cmd.createdAt,\n        createdBy: cmd.createdBy,\n        updatedAt: cmd.updatedAt,\n        updatedBy: cmd.updatedBy,\n      },\n    });\n  }\n\n  private async syncOrderItem(cmd: CommandModel, sk: string): Promise<void> {\n    const attrs = cmd.attributes as OrderItemAttributes;\n\n    await this.prismaService.orderItem.upsert({\n      where: { id: cmd.id },\n      update: {\n        pk: cmd.pk,\n        sk: sk,\n        orderId: attrs.orderId,\n        productId: attrs.productId,\n        quantity: attrs.quantity,\n        unitPrice: attrs.unitPrice,\n        isDeleted: cmd.isDeleted ?? false,\n        updatedAt: cmd.updatedAt,\n      },\n      create: {\n        id: cmd.id,\n        pk: cmd.pk,\n        sk: sk,\n        cpk: cmd.pk,\n        csk: cmd.sk,\n        tenantCode: cmd.tenantCode,\n        orderId: attrs.orderId,\n        productId: attrs.productId,\n        quantity: attrs.quantity,\n        unitPrice: attrs.unitPrice,\n        isDeleted: cmd.isDeleted ?? false,\n        createdAt: cmd.createdAt,\n        updatedAt: cmd.updatedAt,\n      },\n    });\n  }\n\n  async down(cmd: CommandModel): Promise<any> {\n    this.logger.debug(cmd);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"example-3-complex-attribute-transformation",children:"Example 3: Complex Attribute Transformation"}),"\n",(0,s.jsx)(n.h3,{id:"use-case-notifications-with-different-content-types",children:"Use Case: Notifications with Different Content Types"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: Notification entity has different content structures based on type (Alert, Info, Promotion)."}),"\n",(0,s.jsx)(n.p,{children:"Solution: Extract and flatten type-specific fields into common RDS columns."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import {\n  CommandModel,\n  IDataSyncHandler,\n  removeSortKeyVersion\n} from "@mbc-cqrs-serverless/core";\nimport { Injectable, Logger } from "@nestjs/common";\nimport { PrismaService } from "src/prisma";\n\nenum NotificationType {\n  ALERT = "ALERT",\n  INFO = "INFO",\n  PROMOTION = "PROMOTION",\n}\n\ninterface AlertContent {\n  title: string;\n  message: string;\n  severity: string;\n}\n\ninterface InfoContent {\n  headline: string;\n  body: string;\n}\n\ninterface PromotionContent {\n  campaignName: string;\n  discount: number;\n  validUntil: string;\n}\n\ninterface NotificationAttributes {\n  type: NotificationType;\n  alertContent?: AlertContent;\n  infoContent?: InfoContent;\n  promotionContent?: PromotionContent;\n  targetUsers: string[];\n  tags: string[];\n  schedule: {\n    startDate: string;\n    endDate: string;\n  };\n}\n\n@Injectable()\nexport class NotificationDataSyncRdsHandler implements IDataSyncHandler {\n  private readonly logger = new Logger(NotificationDataSyncRdsHandler.name);\n\n  constructor(private readonly prismaService: PrismaService) {}\n\n  async up(cmd: CommandModel): Promise<any> {\n    const sk = removeSortKeyVersion(cmd.sk);\n    const attrs = cmd.attributes as NotificationAttributes;\n\n    // Extract title based on notification type\n    const title = this.getTitle(attrs);\n    const body = this.getBody(attrs);\n\n    await this.prismaService.notification.upsert({\n      where: { id: cmd.id },\n      update: {\n        pk: cmd.pk,\n        sk: sk,\n        code: cmd.code,\n        version: cmd.version,\n        type: attrs.type,\n        title: title,\n        body: body,\n        // Convert arrays to comma-separated strings for RDS\n        targetUsers: attrs.targetUsers?.join(",") ?? null,\n        tags: attrs.tags?.join(",") ?? null,\n        // Handle dates\n        startDate: attrs.schedule?.startDate\n          ? new Date(attrs.schedule.startDate)\n          : null,\n        endDate: attrs.schedule?.endDate\n          ? new Date(attrs.schedule.endDate)\n          : null,\n        isDeleted: cmd.isDeleted ?? false,\n        updatedAt: cmd.updatedAt,\n        updatedBy: cmd.updatedBy,\n      },\n      create: {\n        id: cmd.id,\n        pk: cmd.pk,\n        sk: sk,\n        cpk: cmd.pk,\n        csk: cmd.sk,\n        code: cmd.code,\n        version: cmd.version,\n        tenantCode: cmd.tenantCode,\n        type: attrs.type,\n        title: title,\n        body: body,\n        targetUsers: attrs.targetUsers?.join(",") ?? null,\n        tags: attrs.tags?.join(",") ?? null,\n        startDate: attrs.schedule?.startDate\n          ? new Date(attrs.schedule.startDate)\n          : null,\n        endDate: attrs.schedule?.endDate\n          ? new Date(attrs.schedule.endDate)\n          : null,\n        isDeleted: cmd.isDeleted ?? false,\n        createdAt: cmd.createdAt,\n        createdBy: cmd.createdBy,\n        updatedAt: cmd.updatedAt,\n        updatedBy: cmd.updatedBy,\n      },\n    });\n  }\n\n  /**\n   * Extract title based on notification type\n   */\n  private getTitle(attrs: NotificationAttributes): string | null {\n    switch (attrs.type) {\n      case NotificationType.ALERT:\n        return attrs.alertContent?.title ?? null;\n      case NotificationType.INFO:\n        return attrs.infoContent?.headline ?? null;\n      case NotificationType.PROMOTION:\n        return attrs.promotionContent?.campaignName ?? null;\n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Extract body/message based on notification type\n   */\n  private getBody(attrs: NotificationAttributes): string | null {\n    switch (attrs.type) {\n      case NotificationType.ALERT:\n        return attrs.alertContent?.message ?? null;\n      case NotificationType.INFO:\n        return attrs.infoContent?.body ?? null;\n      case NotificationType.PROMOTION:\n        return `${attrs.promotionContent?.discount}% off until ${attrs.promotionContent?.validUntil}`;\n      default:\n        return null;\n    }\n  }\n\n  async down(cmd: CommandModel): Promise<any> {\n    this.logger.debug(cmd);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"example-4-pk-prefix-filtering",children:"Example 4: PK Prefix Filtering"}),"\n",(0,s.jsx)(n.h3,{id:"use-case-user-records-in-shared-table",children:"Use Case: User Records in Shared Table"}),"\n",(0,s.jsx)(n.p,{children:"Scenario: Multiple entity types share a DynamoDB table. Handler should only process USER records."}),"\n",(0,s.jsx)(n.p,{children:"Solution: Check PK prefix and skip non-matching records early."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import {\n  CommandModel,\n  IDataSyncHandler,\n  KEY_SEPARATOR,\n  removeSortKeyVersion\n} from "@mbc-cqrs-serverless/core";\nimport { Injectable, Logger } from "@nestjs/common";\nimport { PrismaService } from "src/prisma";\n\nconst USER_PK_PREFIX = "USER";\n\ninterface UserAttributes {\n  email: string;\n  userId: string;\n  displayName: string;\n  role: string;\n  lastLoginAt?: string;\n}\n\n@Injectable()\nexport class UserDataSyncRdsHandler implements IDataSyncHandler {\n  private readonly logger = new Logger(UserDataSyncRdsHandler.name);\n\n  constructor(private readonly prismaService: PrismaService) {}\n\n  async up(cmd: CommandModel): Promise<any> {\n    // Only process USER records\n    if (!cmd.pk.startsWith(USER_PK_PREFIX + KEY_SEPARATOR)) {\n      return;\n    }\n\n    // Skip temporary or profile records\n    if (cmd.sk.startsWith("temp") || cmd.sk.startsWith("profile")) {\n      return;\n    }\n\n    const sk = removeSortKeyVersion(cmd.sk);\n    const attrs = cmd.attributes as UserAttributes;\n\n    await this.prismaService.user.upsert({\n      where: { id: cmd.id },\n      update: {\n        pk: cmd.pk,\n        sk: sk,\n        code: cmd.code,\n        version: cmd.version,\n        email: attrs.email,\n        userId: attrs.userId,\n        displayName: attrs.displayName,\n        role: attrs.role,\n        lastLoginAt: attrs.lastLoginAt\n          ? new Date(attrs.lastLoginAt)\n          : null,\n        isDeleted: cmd.isDeleted ?? false,\n        updatedAt: cmd.updatedAt,\n        updatedBy: cmd.updatedBy,\n      },\n      create: {\n        id: cmd.id,\n        pk: cmd.pk,\n        sk: sk,\n        cpk: cmd.pk,\n        csk: cmd.sk,\n        code: cmd.code,\n        version: cmd.version,\n        tenantCode: cmd.tenantCode,\n        type: cmd.type,\n        email: attrs.email,\n        userId: attrs.userId,\n        displayName: attrs.displayName,\n        role: attrs.role,\n        lastLoginAt: attrs.lastLoginAt\n          ? new Date(attrs.lastLoginAt)\n          : null,\n        isDeleted: cmd.isDeleted ?? false,\n        createdAt: cmd.createdAt,\n        createdBy: cmd.createdBy,\n        updatedAt: cmd.updatedAt,\n        updatedBy: cmd.updatedBy,\n      },\n    });\n  }\n\n  async down(cmd: CommandModel): Promise<any> {\n    this.logger.debug(cmd);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"example-5-parsing-sk-for-derived-data",children:"Example 5: Parsing SK for Derived Data"}),"\n",(0,s.jsx)(n.h3,{id:"use-case-master-data-with-category-information-in-sk",children:"Use Case: Master Data with Category Information in SK"}),"\n",(0,s.jsx)(n.p,{children:'Scenario: SK contains structured data like "SETTING#category#code" that should be stored as separate columns.'}),"\n",(0,s.jsx)(n.p,{children:"Solution: Parse SK to extract type, category, and code for querying."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import {\n  CommandModel,\n  IDataSyncHandler,\n  KEY_SEPARATOR,\n  removeSortKeyVersion\n} from "@mbc-cqrs-serverless/core";\nimport { Injectable, Logger } from "@nestjs/common";\nimport { PrismaService } from "src/prisma";\n\nconst SETTING_SK_PREFIX = "SETTING";\nconst DATA_SK_PREFIX = "DATA";\n\ninterface MasterAttributes {\n  value: any;\n  displayOrder: number;\n  isActive: boolean;\n}\n\n@Injectable()\nexport class MasterDataSyncRdsHandler implements IDataSyncHandler {\n  private readonly logger = new Logger(MasterDataSyncRdsHandler.name);\n\n  constructor(private readonly prismaService: PrismaService) {}\n\n  async up(cmd: CommandModel): Promise<any> {\n    const sk = removeSortKeyVersion(cmd.sk);\n    const attrs = cmd.attributes as MasterAttributes;\n\n    // Parse SK to extract type and code\n    // SK format: "SETTING#category#code" or "DATA#category#code"\n    const skParts = sk.split(KEY_SEPARATOR);\n\n    let masterType: string;\n    let masterCategory: string;\n    let masterCode: string;\n\n    if (sk.startsWith(SETTING_SK_PREFIX)) {\n      masterType = "SETTING";\n      masterCategory = skParts[1] ?? "";\n      masterCode = skParts[2] ?? "";\n    } else if (sk.startsWith(DATA_SK_PREFIX)) {\n      masterType = "DATA";\n      masterCategory = skParts[1] ?? "";\n      masterCode = skParts[2] ?? "";\n    } else {\n      // Skip unknown types\n      return;\n    }\n\n    await this.prismaService.master.upsert({\n      where: { id: cmd.id },\n      update: {\n        pk: cmd.pk,\n        sk: sk,\n        code: cmd.code,\n        version: cmd.version,\n        masterType: masterType,\n        masterCategory: masterCategory,\n        masterCode: masterCode,\n        name: cmd.name,\n        value: JSON.stringify(attrs.value),\n        displayOrder: attrs.displayOrder,\n        isActive: attrs.isActive,\n        isDeleted: cmd.isDeleted ?? false,\n        updatedAt: cmd.updatedAt,\n        updatedBy: cmd.updatedBy,\n      },\n      create: {\n        id: cmd.id,\n        pk: cmd.pk,\n        sk: sk,\n        cpk: cmd.pk,\n        csk: cmd.sk,\n        code: cmd.code,\n        version: cmd.version,\n        tenantCode: cmd.tenantCode,\n        masterType: masterType,\n        masterCategory: masterCategory,\n        masterCode: masterCode,\n        name: cmd.name,\n        value: JSON.stringify(attrs.value),\n        displayOrder: attrs.displayOrder,\n        isActive: attrs.isActive,\n        isDeleted: cmd.isDeleted ?? false,\n        createdAt: cmd.createdAt,\n        createdBy: cmd.createdBy,\n        updatedAt: cmd.updatedAt,\n        updatedBy: cmd.updatedBy,\n      },\n    });\n  }\n\n  async down(cmd: CommandModel): Promise<any> {\n    this.logger.debug(cmd);\n  }\n}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"registering-multiple-handlers",children:"Registering Multiple Handlers"}),"\n",(0,s.jsx)(n.p,{children:"You can register multiple handlers for the same table to handle different record types:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'import { CommandModule } from "@mbc-cqrs-serverless/core";\nimport { Module } from "@nestjs/common";\n\nimport { OrderDataSyncRdsHandler } from "./handler/order-rds.handler";\nimport { OrderItemDataSyncRdsHandler } from "./handler/order-item-rds.handler";\nimport { OrderHistoryDataSyncRdsHandler } from "./handler/order-history-rds.handler";\nimport { OrderController } from "./order.controller";\nimport { OrderService } from "./order.service";\n\n@Module({\n  imports: [\n    CommandModule.register({\n      tableName: "order",\n      dataSyncHandlers: [\n        OrderDataSyncRdsHandler,\n        OrderItemDataSyncRdsHandler,\n        OrderHistoryDataSyncRdsHandler,\n      ],\n    }),\n  ],\n  controllers: [OrderController],\n  providers: [OrderService],\n})\nexport class OrderModule {}\n'})}),"\n",(0,s.jsx)(n.h2,{id:"best-practices",children:"Best Practices"}),"\n",(0,s.jsx)(n.h3,{id:"1-always-remove-version-from-sk",children:"1. Always Remove Version from SK"}),"\n",(0,s.jsxs)(n.p,{children:["Use ",(0,s.jsx)(n.code,{children:"removeSortKeyVersion()"})," to get a consistent SK for RDS storage:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'const sk = removeSortKeyVersion(cmd.sk); // "ORDER001@3" -> "ORDER001"\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-handle-undefined-isdeleted",children:"2. Handle undefined isDeleted"}),"\n",(0,s.jsxs)(n.p,{children:["Always provide a default value for ",(0,s.jsx)(n.code,{children:"isDeleted"}),":"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"isDeleted: cmd.isDeleted ?? false,\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-store-both-original-and-cleaned-keys",children:"3. Store Both Original and Cleaned Keys"}),"\n",(0,s.jsx)(n.p,{children:"Store original keys (cpk, csk) in create operations for reference:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"create: {\n  pk: cmd.pk,     // Cleaned PK\n  sk: sk,         // Cleaned SK (without version)\n  cpk: cmd.pk,    // Original PK (same as pk for most cases)\n  csk: cmd.sk,    // Original SK (with version)\n  // ...\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"4-type-your-attributes",children:"4. Type Your Attributes"}),"\n",(0,s.jsx)(n.p,{children:"Define interfaces for attributes to ensure type safety:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"interface ProductAttributes {\n  name: string;\n  price: number;\n  // ...\n}\n\nconst attrs = cmd.attributes as ProductAttributes;\n"})}),"\n",(0,s.jsx)(n.h3,{id:"5-handle-nullundefined-gracefully",children:"5. Handle Null/Undefined Gracefully"}),"\n",(0,s.jsx)(n.p,{children:"Use nullish coalescing and optional chaining:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'tags: attrs.tags?.join(",") ?? null,\nstartDate: attrs.schedule?.startDate\n  ? new Date(attrs.schedule.startDate)\n  : null,\n'})})]})}function m(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>d,x:()=>i});var r=t(6540);const s={},a=r.createContext(s);function d(e){const n=r.useContext(a);return r.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function i(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:d(e.components),r.createElement(a.Provider,{value:n},e.children)}}}]);