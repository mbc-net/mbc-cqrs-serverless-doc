{
  "Practical examples of implementing Data Sync Handlers for various use cases.": "Practical examples of implementing Data Sync Handlers for various use cases.",
  "Data Sync Handler Examples": "Data Sync Handler Examples",
  "This guide explains how to implement Data Sync Handlers that automatically synchronize data from DynamoDB (command source) to RDS (query database). This is the core mechanism that enables the CQRS read model.": "This guide explains how to implement Data Sync Handlers that automatically synchronize data from DynamoDB (command source) to RDS (query database). This is the core mechanism that enables the CQRS read model.",
  "When to Use This Guide": "When to Use This Guide",
  "Use this guide when you need to:": "Use this guide when you need to:",
  "Sync entity data from DynamoDB to MySQL/PostgreSQL for complex queries": "Sync entity data from DynamoDB to MySQL/PostgreSQL for complex queries",
  "Transform nested JSON attributes into relational columns": "Transform nested JSON attributes into relational columns",
  "Handle different record types within the same DynamoDB table": "Handle different record types within the same DynamoDB table",
  "Process parent-child relationships (Order, OrderItem) separately": "Process parent-child relationships (Order, OrderItem) separately",
  "Problems This Pattern Solves": "Problems This Pattern Solves",
  "Problem": "Problem",
  "Solution": "Solution",
  "DynamoDB cannot do JOINs or complex filters": "DynamoDB cannot do JOINs or complex filters",
  "Sync data to RDS for SQL queries": "Sync data to RDS for SQL queries",
  "Version suffix in SK causes duplicate records": "Version suffix in SK causes duplicate records",
  "Use removeSortKeyVersion() before upserting": "Use removeSortKeyVersion() before upserting",
  "Different record types need different RDS tables": "Different record types need different RDS tables",
  "Filter by SK prefix in handler": "Filter by SK prefix in handler",
  "JSON attributes need to be searchable columns": "JSON attributes need to be searchable columns",
  "Map attributes to individual RDS columns": "Map attributes to individual RDS columns",
  "Basic Structure": "Basic Structure",
  "All Data Sync Handlers follow this basic structure:": "All Data Sync Handlers follow this basic structure:",
  "Example 1: Simple Entity Sync": "Example 1: Simple Entity Sync",
  "Use Case: Sync Products to Enable Search and Filtering": "Use Case: Sync Products to Enable Search and Filtering",
  "Scenario: Products stored in DynamoDB need to be searchable by category, price range, and text.": "Scenario: Products stored in DynamoDB need to be searchable by category, price range, and text.",
  "Solution: Sync to RDS and map attributes to indexed columns for efficient queries.": "Solution: Sync to RDS and map attributes to indexed columns for efficient queries.",
  "Example 2: Conditional Processing with SK Prefix": "Example 2: Conditional Processing with SK Prefix",
  "Use Case: Order and OrderItem in Same DynamoDB Table": "Use Case: Order and OrderItem in Same DynamoDB Table",
  "Scenario: Orders and their items share the same PK but have different SK prefixes. Each needs to go to a different RDS table.": "Scenario: Orders and their items share the same PK but have different SK prefixes. Each needs to go to a different RDS table.",
  "Solution: Check SK prefix to route to appropriate sync logic.": "Solution: Check SK prefix to route to appropriate sync logic.",
  "Example 3: Complex Attribute Transformation": "Example 3: Complex Attribute Transformation",
  "Use Case: Notifications with Different Content Types": "Use Case: Notifications with Different Content Types",
  "Scenario: Notification entity has different content structures based on type (Alert, Info, Promotion).": "Scenario: Notification entity has different content structures based on type (Alert, Info, Promotion).",
  "Solution: Extract and flatten type-specific fields into common RDS columns.": "Solution: Extract and flatten type-specific fields into common RDS columns.",
  "Example 4: PK Prefix Filtering": "Example 4: PK Prefix Filtering",
  "Use Case: User Records in Shared Table": "Use Case: User Records in Shared Table",
  "Scenario: Multiple entity types share a DynamoDB table. Handler should only process USER records.": "Scenario: Multiple entity types share a DynamoDB table. Handler should only process USER records.",
  "Solution: Check PK prefix and skip non-matching records early.": "Solution: Check PK prefix and skip non-matching records early.",
  "Example 5: Parsing SK for Derived Data": "Example 5: Parsing SK for Derived Data",
  "Use Case: Master Data with Category Information in SK": "Use Case: Master Data with Category Information in SK",
  "Scenario: SK contains structured data like \"SETTING#category#code\" that should be stored as separate columns.": "Scenario: SK contains structured data like \"SETTING#category#code\" that should be stored as separate columns.",
  "Solution: Parse SK to extract type, category, and code for querying.": "Solution: Parse SK to extract type, category, and code for querying.",
  "Registering Multiple Handlers": "Registering Multiple Handlers",
  "You can register multiple handlers for the same table to handle different record types:": "You can register multiple handlers for the same table to handle different record types:",
  "Best Practices": "Best Practices",
  "1. Always Remove Version from SK": "1. Always Remove Version from SK",
  "Use `removeSortKeyVersion()` to get a consistent SK for RDS storage:": "Use `removeSortKeyVersion()` to get a consistent SK for RDS storage:",
  "2. Handle undefined isDeleted": "2. Handle undefined isDeleted",
  "Always provide a default value for `isDeleted`:": "Always provide a default value for `isDeleted`:",
  "3. Store Both Original and Cleaned Keys": "3. Store Both Original and Cleaned Keys",
  "Store original keys (cpk, csk) in create operations for reference:": "Store original keys (cpk, csk) in create operations for reference:",
  "4. Type Your Attributes": "4. Type Your Attributes",
  "Define interfaces for attributes to ensure type safety:": "Define interfaces for attributes to ensure type safety:",
  "5. Handle Null/Undefined Gracefully": "5. Handle Null/Undefined Gracefully",
  "Use nullish coalescing and optional chaining:": "Use nullish coalescing and optional chaining:"
}