{
  "Learn how to implement service layer with CRUD operations using CommandService and DataService.": "CommandServiceとDataServiceを使用したCRUD操作によるサービスレイヤーの実装方法を学びます。",
  "Service Implementation Patterns": "Service実装パターン",
  "This guide explains how to implement service classes that handle CRUD operations in MBC CQRS Serverless. Services are the core of your business logic, coordinating between controllers, commands, and data access.": "このガイドでは、MBC CQRS ServerlessでCRUD操作を処理するサービスクラスの実装方法を説明します。サービスはビジネスロジックの中核であり、コントローラー、コマンド、データアクセスを調整します。",
  "When to Use This Guide": "このガイドを使用するタイミング",
  "Use this guide when you need to:": "以下が必要な場合にこのガイドを使用してください：",
  "Build a service layer for a new domain entity": "新しいドメインエンティティのサービスレイヤーを構築する",
  "Implement create, read, update, delete (CRUD) operations": "作成、読み取り、更新、削除（CRUD）操作を実装する",
  "Handle multi-tenant data isolation": "マルチテナントデータの分離を処理する",
  "Use optimistic locking for concurrent updates": "並行更新のための楽観的ロックを使用する",
  "Implement batch operations for bulk data processing": "大量データ処理のためのバッチ操作を実装する",
  "Problems This Pattern Solves": "このパターンが解決する問題",
  "Problem": "問題",
  "Solution": "解決策",
  "Direct database access bypasses CQRS pattern": "データベースへの直接アクセスはCQRSパターンをバイパスする",
  "Use CommandService for writes, DataService for reads": "書き込みにはCommandService、読み取りにはDataServiceを使用する",
  "No audit trail for data changes": "データ変更の監査証跡がない",
  "Pass invokeContext to capture user and timestamp": "ユーザーとタイムスタンプを記録するためにinvokeContextを渡す",
  "Concurrent updates overwrite each other": "並行更新が互いを上書きする",
  "Use version field for optimistic locking": "楽観的ロックのためにversionフィールドを使用する",
  "Slow responses due to synchronous processing": "同期処理による遅いレスポンス",
  "Use publishAsync for non-blocking command publishing": "非ブロッキングコマンド発行のためにpublishAsyncを使用する",
  "Basic Service Structure": "基本的なService構造",
  "A typical service uses both `CommandService` for write operations and `DataService` for read operations:": "一般的なサービスは、書き込み操作に`CommandService`、読み取り操作に`DataService`の両方を使用します：",
  "Create Operation": "Create操作",
  "Use Case: Create a New Product": "ユースケース：新しい商品を作成する",
  "Scenario: User submits a form to add a new product to the catalog.": "シナリオ：ユーザーがカタログに新しい商品を追加するフォームを送信する。",
  "Flow: Controller receives CreateProductDto → Service generates keys → Command published to DynamoDB → Data synced to RDS.": "フロー：ControllerがCreateProductDtoを受信 → Serviceがキーを生成 → CommandがDynamoDBに発行 → データがRDSに同期。",
  "Read Operations": "Read操作",
  "Find One by Key": "キーによる単一取得",
  "Use Case: Get Product Detail Page": "ユースケース：商品詳細ページを取得する",
  "Scenario: User navigates to a product detail page and needs the full product data.": "シナリオ：ユーザーが商品詳細ページに移動し、完全な商品データが必要。",
  "When to use: Single-item lookup where you have the pk and sk.": "使用するタイミング：pkとskがある場合の単一アイテム検索。",
  "Find All with Pagination (from RDS)": "ページネーション付き全件取得（RDSから）",
  "Use Case: Product List with Filtering": "ユースケース：フィルタリング付き商品リスト",
  "Scenario: Display a paginated product list that users can filter by category or search.": "シナリオ：ユーザーがカテゴリや検索でフィルタリングできるページネーション付き商品リストを表示する。",
  "Why RDS: DynamoDB is not optimized for complex queries. Use Prisma/RDS for filtering and full-text search.": "RDSを使用する理由：DynamoDBは複雑なクエリに最適化されていません。フィルタリングと全文検索にはPrisma/RDSを使用します。",
  "Update Operation": "Update操作",
  "Use Case: Edit Product Details": "ユースケース：商品詳細を編集する",
  "Scenario: User updates product name or price through an edit form.": "シナリオ：ユーザーが編集フォームで商品名や価格を更新する。",
  "Important: Include the version field to enable optimistic locking and prevent concurrent update conflicts.": "重要：楽観的ロックを有効にし、並行更新の競合を防ぐためにversionフィールドを含めてください。",
  "Delete Operation (Soft Delete)": "Delete操作（論理削除）",
  "Use Case: Remove Product from Catalog": "ユースケース：カタログから商品を削除する",
  "Scenario: Admin removes a discontinued product.": "シナリオ：管理者が廃止商品を削除する。",
  "Why Soft Delete: Data is marked as deleted (isDeleted=true) rather than physically removed, preserving audit history.": "論理削除の理由：データは物理的に削除されるのではなく、削除済み（isDeleted=true）としてマークされ、監査履歴が保持されます。",
  "Complete Service Example": "完全なService例",
  "Here is a complete service implementation:": "完全なサービス実装を示します：",
  "Batch Operations": "バッチ操作",
  "Use Case: Import Multiple Products": "ユースケース：複数の商品をインポートする",
  "Scenario: Admin uploads a CSV file containing multiple products to import.": "シナリオ：管理者がインポートする複数の商品を含むCSVファイルをアップロードする。",
  "Solution: Process items in parallel using Promise.all for better performance.": "解決策：パフォーマンス向上のためにPromise.allを使用してアイテムを並列処理する。",
  "Chunked Batch Operations": "チャンク化バッチ操作",
  "Use Case: Large Data Migration": "ユースケース：大規模データ移行",
  "Scenario: Migrating thousands of records from a legacy system.": "シナリオ：レガシーシステムから数千件のレコードを移行する。",
  "Problem: Processing all at once may cause Lambda timeout or memory issues.": "問題：一度に全て処理するとLambdaのタイムアウトやメモリの問題が発生する可能性がある。",
  "Solution: Process in chunks of 100 items to stay within Lambda limits.": "解決策：Lambdaの制限内に収めるために100アイテムのチャンクで処理する。",
  "Copy Operation": "Copy操作",
  "Use Case: Clone Product to Different Tenant": "ユースケース：商品を別のテナントにクローンする",
  "Scenario: Multi-tenant SaaS where a template product needs to be copied to a new tenant.": "シナリオ：テンプレート商品を新しいテナントにコピーする必要があるマルチテナントSaaS。",
  "Solution: Read source entity and create new entity with different tenant's keys.": "解決策：ソースエンティティを読み取り、異なるテナントのキーで新しいエンティティを作成する。",
  "Using History Service": "History Serviceの使用",
  "Use Case: View Previous Versions of a Document": "ユースケース：ドキュメントの以前のバージョンを表示する",
  "Scenario: Audit requirement to show what a document looked like at a specific version.": "シナリオ：特定のバージョンでドキュメントがどのようだったかを表示する監査要件。",
  "Solution: Use HistoryService to retrieve a specific version from the history table.": "解決策：HistoryServiceを使用して履歴テーブルから特定のバージョンを取得する。",
  "Best Practices": "ベストプラクティス",
  "1. Always Use Invoke Context": "1. 常にInvoke Contextを使用する",
  "Pass invoke context for audit trail:": "監査証跡のためにinvoke contextを渡します：",
  "2. Use Optimistic Locking": "2. 楽観的ロックを使用する",
  "Include version in partial updates:": "部分更新にバージョンを含めます：",
  "3. Prefer Async Operations": "3. 非同期操作を優先する",
  "Use async methods for better responsiveness:": "レスポンシブ性向上のために非同期メソッドを使用します：",
  "4. Combine DynamoDB and RDS Queries": "4. DynamoDBとRDSクエリを組み合わせる",
  "Use DynamoDB for single-item reads, RDS for complex queries:": "単一アイテムの読み取りにはDynamoDB、複雑なクエリにはRDSを使用します："
}
