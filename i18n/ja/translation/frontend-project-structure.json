{
  "Learn how to structure your Next.js frontend project for MBC CQRS Serverless applications.": "MBC CQRS ServerlessアプリケーションのためのNext.jsフロントエンドプロジェクトの構造化方法を学びます。",
  "Frontend Project Structure": "フロントエンドプロジェクト構造",
  "This guide explains how to organize a Next.js frontend application that integrates with an MBC CQRS Serverless backend. A well-structured project improves maintainability, enables team collaboration, and scales effectively as the application grows.": "このガイドでは、MBC CQRS Serverlessバックエンドと統合するNext.jsフロントエンドアプリケーションの構成方法を説明します。適切に構造化されたプロジェクトは、保守性を向上させ、チームコラボレーションを可能にし、アプリケーションの成長に合わせて効果的にスケールします。",
  "When to Use This Guide": "このガイドを使用するタイミング",
  "Use this guide when you are:": "以下の場合にこのガイドを使用してください：",
  "Building a new frontend application that connects to an MBC CQRS Serverless API": "MBC CQRS Serverless APIに接続する新しいフロントエンドアプリケーションを構築する場合",
  "Migrating an existing React application to Next.js with App Router": "既存のReactアプリケーションをApp Router付きのNext.jsに移行する場合",
  "Setting up a multi-tenant SaaS application with Cognito authentication": "Cognito認証を使用したマルチテナントSaaSアプリケーションを構築する場合",
  "Creating an admin panel or dashboard for CQRS-based data management": "CQRSベースのデータ管理用の管理画面やダッシュボードを作成する場合",
  "Problems This Structure Solves": "この構造が解決する問題",
  "Problem": "問題",
  "Solution": "解決策",
  "Mixing server and client code causes hydration errors": "サーバーコードとクライアントコードの混在がハイドレーションエラーを引き起こす",
  "Separate containers (client) from pages (server)": "コンテナ（クライアント）をページ（サーバー）から分離する",
  "API types get out of sync with backend": "API型がバックエンドと同期しなくなる",
  "Use generated OpenAPI SDK in services/sdk": "services/sdkで生成されたOpenAPI SDKを使用する",
  "State management becomes chaotic": "状態管理が混乱する",
  "Separate server state (React Query) from client state (Zustand)": "サーバー状態（React Query）をクライアント状態（Zustand）から分離する",
  "Components become too large and hard to test": "コンポーネントが大きくなりすぎてテストが困難になる",
  "Split into ui (presentation), forms (input), and containers (logic)": "ui（プレゼンテーション）、forms（入力）、containers（ロジック）に分割する",
  "Authentication logic scattered across files": "認証ロジックがファイル全体に散らばる",
  "Centralize in lib/auth with Amplify configuration": "lib/authにAmplify設定を集中させる",
  "Technology Stack": "技術スタック",
  "Category": "カテゴリ",
  "Technology": "技術",
  "Purpose": "目的",
  "Framework": "フレームワーク",
  "React framework with App Router": "App Router付きReactフレームワーク",
  "Language": "言語",
  "Type-safe development": "型安全な開発",
  "State Management": "状態管理",
  "Client-side state management": "クライアント側状態管理",
  "Server State": "サーバー状態",
  "Server state caching and synchronization": "サーバー状態のキャッシュと同期",
  "Forms": "フォーム",
  "Form handling with validation": "バリデーション付きフォーム処理",
  "Authentication": "認証",
  "Cognito integration": "Cognito統合",
  "API Client": "APIクライアント",
  "Type-safe API calls": "型安全なAPI呼び出し",
  "Styling": "スタイリング",
  "Utility-first CSS": "ユーティリティファーストCSS",
  "UI Components": "UIコンポーネント",
  "Component library": "コンポーネントライブラリ",
  "Directory Structure": "ディレクトリ構造",
  "The following structure separates concerns clearly and scales well for medium to large applications:": "以下の構造は関心事を明確に分離し、中〜大規模アプリケーションに適切にスケールします：",
  "Key Directory Explanations": "主要ディレクトリの説明",
  "app/ - Page Routes": "app/ - ページルート",
  "Use Case: Define URL routes and page metadata. Pages should be thin wrappers that import containers.": "ユースケース：URLルートとページメタデータを定義します。ページはコンテナをインポートする薄いラッパーであるべきです。",
  "Why: Next.js App Router uses file-based routing. Keeping pages simple allows containers to be tested independently.": "理由：Next.js App Routerはファイルベースのルーティングを使用します。ページをシンプルに保つことで、コンテナを独立してテストできます。",
  "containers/ - Business Logic": "containers/ - ビジネスロジック",
  "Use Case: Handle data fetching, state management, and user interactions for specific features.": "ユースケース：特定機能のデータ取得、状態管理、ユーザーインタラクションを処理します。",
  "Why: Separating business logic from presentation makes components reusable and testable.": "理由：ビジネスロジックをプレゼンテーションから分離することで、コンポーネントが再利用可能でテスト可能になります。",
  "components/ui/ - Design System": "components/ui/ - デザインシステム",
  "Use Case: Build consistent UI elements used across the application.": "ユースケース：アプリケーション全体で使用する一貫したUI要素を構築します。",
  "Why: A shared component library ensures visual consistency and reduces code duplication.": "理由：共有コンポーネントライブラリは視覚的な一貫性を確保し、コードの重複を減らします。",
  "services/sdk/ - API Types": "services/sdk/ - API型",
  "Use Case: Auto-generated TypeScript types and API clients from OpenAPI specification.": "ユースケース：OpenAPI仕様から自動生成されたTypeScript型とAPIクライアント。",
  "Why: Ensures frontend types match backend exactly, catching type errors at compile time.": "理由：フロントエンドの型がバックエンドと正確に一致することを保証し、コンパイル時に型エラーを検出します。",
  "stores/ - Client State": "stores/ - クライアント状態",
  "Use Case: Manage UI state like sidebar open/close, theme, selected tenant.": "ユースケース：サイドバーの開閉、テーマ、選択されたテナントなどのUI状態を管理します。",
  "Why: Zustand provides simple, performant state management without boilerplate.": "理由：Zustandはボイラープレートなしでシンプルかつ高性能な状態管理を提供します。",
  "hooks/ - React Query Hooks": "hooks/ - React Queryフック",
  "Use Case: Wrap API calls with caching, loading states, and error handling.": "ユースケース：API呼び出しをキャッシュ、ローディング状態、エラーハンドリングでラップします。",
  "Why: React Query handles server state complexity (caching, refetching, optimistic updates).": "理由：React Queryはサーバー状態の複雑さ（キャッシュ、再取得、楽観的更新）を処理します。",
  "App Router Structure": "App Router構造",
  "Route Groups": "ルートグループ",
  "Use Case: Organize routes by authentication requirement without affecting URLs.": "ユースケース：URLに影響を与えずに認証要件でルートを整理します。",
  "Example: (auth) group for login/register pages, (main) group for authenticated pages.": "例：ログイン/登録ページ用の(auth)グループ、認証済みページ用の(main)グループ。",
  "Layout Pattern": "レイアウトパターン",
  "Use Case: Share common UI elements (header, sidebar) across multiple pages.": "ユースケース：複数のページ間で共通のUI要素（ヘッダー、サイドバー）を共有します。",
  "Example: Main layout with navigation for all authenticated pages.": "例：すべての認証済みページ用のナビゲーション付きメインレイアウト。",
  "Page Pattern": "ページパターン",
  "Use Case: Define route entry points that delegate to containers.": "ユースケース：コンテナに委譲するルートエントリーポイントを定義します。",
  "Why: Pages handle metadata (title, description) while containers handle rendering logic.": "理由：ページはメタデータ（タイトル、説明）を処理し、コンテナはレンダリングロジックを処理します。",
  "Component Organization": "コンポーネント構成",
  "Use Case: Create reusable, styled components that accept props for customization.": "ユースケース：カスタマイズ用のpropsを受け取る再利用可能なスタイル付きコンポーネントを作成します。",
  "Example: A Button component with variants for different contexts (primary action, danger, secondary).": "例：異なるコンテキスト用のバリアント（プライマリアクション、危険、セカンダリ）を持つButtonコンポーネント。",
  "Container Components": "コンテナコンポーネント",
  "Use Case: Combine data fetching, business logic, and UI composition for a feature.": "ユースケース：機能のためのデータ取得、ビジネスロジック、UI構成を組み合わせます。",
  "Example: ProductList container that fetches products, handles loading/error states, and renders the list.": "例：商品を取得し、ローディング/エラー状態を処理し、リストをレンダリングするProductListコンテナ。",
  "Provider Setup": "プロバイダー設定",
  "Root Providers": "ルートプロバイダー",
  "Use Case: Configure global providers (React Query, Authentication) once at the app root.": "ユースケース：アプリのルートでグローバルプロバイダー（React Query、認証）を一度設定します。",
  "Why: Providers wrap the entire application to share context across all pages.": "理由：プロバイダーはアプリケーション全体をラップして、すべてのページ間でコンテキストを共有します。",
  "Root Layout": "ルートレイアウト",
  "Use Case: Apply providers and global styles to all pages.": "ユースケース：すべてのページにプロバイダーとグローバルスタイルを適用します。",
  "Environment Configuration": "環境設定",
  "Environment Variables": "環境変数",
  "Use Case: Configure different settings for development, staging, and production environments.": "ユースケース：開発、ステージング、本番環境用に異なる設定を構成します。",
  "Configuration Module": "設定モジュール",
  "Use Case: Centralize configuration access with type safety and defaults.": "ユースケース：型安全性とデフォルト値で設定アクセスを集中管理します。",
  "Best Practices": "ベストプラクティス",
  "1. Separate Server and Client Components": "1. サーバーコンポーネントとクライアントコンポーネントを分離する",
  "Problem: Using hooks in server components causes errors.": "問題：サーバーコンポーネントでフックを使用するとエラーが発生します。",
  "Solution: Mark components using hooks or browser APIs with 'use client'.": "解決策：フックやブラウザAPIを使用するコンポーネントに'use client'をマークします。",
  "2. Use Path Aliases": "2. パスエイリアスを使用する",
  "Problem: Deep relative imports like '../../../components' are hard to read and refactor.": "問題：'../../../components'のような深い相対インポートは読みにくく、リファクタリングが困難です。",
  "Solution: Configure path aliases for clean imports.": "解決策：クリーンなインポートのためにパスエイリアスを設定します。",
  "3. Consistent File Naming": "3. 一貫したファイル命名",
  "Type": "タイプ",
  "Convention": "規則",
  "Example": "例",
  "Components": "コンポーネント",
  "Hooks": "フック",
  "Utilities": "ユーティリティ",
  "Types": "型",
  "Constants": "定数",
  "4. Export Patterns": "4. エクスポートパターン",
  "Use Case: Create clean public APIs for directories.": "ユースケース：ディレクトリ用のクリーンな公開APIを作成します。",
  "5. Type-Safe Route Constants": "5. 型安全なルート定数",
  "Use Case: Avoid typos in route strings and enable autocomplete.": "ユースケース：ルート文字列のタイプミスを防ぎ、自動補完を有効にします。"
}
