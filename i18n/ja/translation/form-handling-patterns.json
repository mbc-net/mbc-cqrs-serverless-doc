{
  "Learn how to handle forms effectively using React Hook Form with Zod validation.": "React Hook FormとZodバリデーションを使用したフォームの効果的な処理方法を学びます。",
  "Form Handling Patterns": "フォーム処理パターン",
  "This guide explains how to build type-safe forms with validation using React Hook Form and Zod. These patterns ensure data integrity before sending to the API and provide clear feedback to users.": "このガイドでは、React Hook FormとZodを使用した型安全なフォームとバリデーションの構築方法を説明します。これらのパターンはAPIに送信する前にデータの整合性を確保し、ユーザーに明確なフィードバックを提供します。",
  "When to Use This Guide": "このガイドを使用するタイミング",
  "Use this guide when you need to:": "以下が必要な場合にこのガイドを使用してください：",
  "Build forms for creating and editing entities (products, users, orders)": "エンティティ（製品、ユーザー、注文）の作成・編集用フォームを構築する",
  "Validate user input before submitting to the API": "APIに送信する前にユーザー入力を検証する",
  "Display field-level error messages to users": "フィールドレベルのエラーメッセージをユーザーに表示する",
  "Handle complex forms with dynamic fields (order items, tags)": "動的フィールド（注文アイテム、タグ）を持つ複雑なフォームを処理する",
  "Show conditional fields based on other form values": "他のフォーム値に基づいて条件付きフィールドを表示する",
  "Problems This Pattern Solves": "このパターンが解決する問題",
  "Problem": "問題",
  "Solution": "解決策",
  "Invalid data sent to API": "無効なデータがAPIに送信される",
  "Zod validates before submission": "Zodが送信前に検証する",
  "Type mismatch between form and API": "フォームとAPIの型が一致しない",
  "Infer TypeScript types from Zod schema": "ZodスキーマからTypeScript型を推論する",
  "Form re-renders on every keystroke": "キー入力ごとにフォームが再レンダリングされる",
  "React Hook Form uses uncontrolled inputs": "React Hook Formは非制御入力を使用する",
  "Hard to show validation errors": "バリデーションエラーを表示しにくい",
  "Automatic error state per field": "フィールドごとの自動エラー状態",
  "Dynamic fields are complex to manage": "動的フィールドの管理が複雑",
  "useFieldArray handles add/remove": "useFieldArrayが追加/削除を処理する",
  "Technology Stack": "技術スタック",
  "Library": "ライブラリ",
  "Purpose": "目的",
  "Form state management": "フォーム状態管理",
  "Schema validation": "スキーマバリデーション",
  "Zod integration": "Zod統合",
  "Installation": "インストール",
  "Basic Form Structure": "基本的なフォーム構造",
  "Use Case: Product Create Form": "ユースケース: 製品作成フォーム",
  "Scenario: User needs to create a new product with code, name, price, and status.": "シナリオ: ユーザーがコード、名前、価格、ステータスを持つ新しい製品を作成する必要がある。",
  "Solution: Define schema with validation rules, create form component that displays errors.": "解決策: バリデーションルール付きのスキーマを定義し、エラーを表示するフォームコンポーネントを作成する。",
  "Zod Schema Definition": "Zodスキーマ定義",
  "Define validation rules that match your API requirements:": "API要件に合致するバリデーションルールを定義します：",
  "Form Component": "フォームコンポーネント",
  "Connect the schema to React Hook Form:": "スキーマをReact Hook Formに接続します：",
  "Reusable Form Components": "再利用可能なフォームコンポーネント",
  "Use Case: Consistent Form Field Styling": "ユースケース: 一貫したフォームフィールドスタイリング",
  "Scenario: All form fields should have consistent label, error display, and required indicator.": "シナリオ: すべてのフォームフィールドは一貫したラベル、エラー表示、必須インジケーターを持つべき。",
  "Solution: Create a wrapper component that handles common field UI.": "解決策: 共通フィールドUIを処理するラッパーコンポーネントを作成する。",
  "Use Case: Input with Error State": "ユースケース: エラー状態付きの入力",
  "Scenario: Input should visually indicate validation errors.": "シナリオ: 入力はバリデーションエラーを視覚的に示すべき。",
  "Advanced Form Patterns": "高度なフォームパターン",
  "Use Case: Order Form with Multiple Items": "ユースケース: 複数アイテムを持つ注文フォーム",
  "Scenario: User creates an order with multiple line items. Items can be added or removed.": "シナリオ: ユーザーが複数の明細を持つ注文を作成する。アイテムは追加・削除可能。",
  "Problem: Managing array of fields with validation is complex.": "問題: バリデーション付きのフィールド配列の管理が複雑。",
  "Solution: useFieldArray provides add, remove, and update methods with proper validation.": "解決策: useFieldArrayが適切なバリデーションと共に追加、削除、更新メソッドを提供する。",
  "Use Case: Payment Form with Conditional Fields": "ユースケース: 条件付きフィールドを持つ支払いフォーム",
  "Scenario: Form shows different fields based on payment method selection.": "シナリオ: フォームが支払い方法の選択に基づいて異なるフィールドを表示する。",
  "Problem: Need to watch a field value and conditionally render other fields.": "問題: フィールド値を監視し、条件に応じて他のフィールドをレンダリングする必要がある。",
  "Solution: useWatch subscribes to field changes without causing full form re-render.": "解決策: useWatchがフォーム全体の再レンダリングを起こさずにフィールド変更を監視する。",
  "Form with React Query": "React Query付きフォーム",
  "Use Case: Create Product with API Integration": "ユースケース: API統合による製品作成",
  "Scenario: Submit form data to API and handle success/error states.": "シナリオ: フォームデータをAPIに送信し、成功/エラー状態を処理する。",
  "Solution: Container component combines form with React Query mutation.": "解決策: コンテナコンポーネントがフォームとReact Queryミューテーションを組み合わせる。",
  "Use Case: Edit Product with Pre-populated Data": "ユースケース: 事前入力データによる製品編集",
  "Scenario: Load existing product data into form for editing.": "シナリオ: 編集のために既存の製品データをフォームに読み込む。",
  "Problem: Need to fetch data before rendering form with default values.": "問題: デフォルト値を持つフォームをレンダリングする前にデータを取得する必要がある。",
  "Solution: Container fetches data, passes to form as defaultValues.": "解決策: コンテナがデータを取得し、defaultValuesとしてフォームに渡す。",
  "Complex Validation Patterns": "複雑なバリデーションパターン",
  "Use Case: Date Range Validation": "ユースケース: 日付範囲バリデーション",
  "Scenario: End date must be after start date.": "シナリオ: 終了日は開始日より後でなければならない。",
  "Solution: Use Zod refine to validate across multiple fields.": "解決策: Zod refineを使用して複数フィールドにわたるバリデーションを行う。",
  "Use Case: Unique Code Validation": "ユースケース: 一意コードバリデーション",
  "Scenario: Product code must not already exist in database.": "シナリオ: 製品コードはデータベースに既に存在してはならない。",
  "Problem: Need to call API to check uniqueness.": "問題: 一意性を確認するためにAPIを呼び出す必要がある。",
  "Solution: Use async refine to validate against API.": "解決策: async refineを使用してAPIに対してバリデーションを行う。",
  "Best Practices": "ベストプラクティス",
  "1. Colocate Schemas with Forms": "1. スキーマをフォームと同じ場所に配置する",
  "Why: Keeps validation logic close to the form that uses it.": "理由: バリデーションロジックをそれを使用するフォームの近くに保つ。",
  "2. Use Mode Appropriately": "2. モードを適切に使用する",
  "Choose validation timing based on form complexity:": "フォームの複雑さに基づいてバリデーションのタイミングを選択します：",
  "3. Extract Common Schemas": "3. 共通スキーマを抽出する",
  "Why: Reuse validation rules across multiple forms.": "理由: 複数のフォームでバリデーションルールを再利用する。",
  "4. Handle Server Errors": "4. サーバーエラーを処理する",
  "Scenario: Server returns field-level validation errors.": "シナリオ: サーバーがフィールドレベルのバリデーションエラーを返す。",
  "Solution: Use setError to display server errors on specific fields.": "解決策: setErrorを使用してサーバーエラーを特定のフィールドに表示する。"
}
