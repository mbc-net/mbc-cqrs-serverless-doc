{
  "Learn how to handle forms effectively using React Hook Form with Zod validation.": "React Hook FormとZodバリデーションを使用したフォームの効果的な処理方法を学びます。",
  "Form Handling Patterns": "フォーム処理パターン",
  "This guide explains how to build type-safe forms with validation using React Hook Form and Zod. These patterns ensure data integrity before sending to the API and provide clear feedback to users.": "このガイドでは、React Hook FormとZodを使用した型安全なフォームとバリデーションの構築方法を説明します。これらのパターンはAPIに送信する前にデータの整合性を確保し、ユーザーに明確なフィードバックを提供します。",
  "When to Use This Guide": "このガイドを使用するタイミング",
  "Use this guide when you need to:": "以下が必要な場合にこのガイドを使用してください：",
  "Build forms for creating and editing entities (products, users, orders)": "エンティティ（製品、ユーザー、注文）の作成・編集用フォームを構築する",
  "Validate user input before submitting to the API": "APIに送信する前にユーザー入力を検証する",
  "Display field-level error messages to users": "フィールドレベルのエラーメッセージをユーザーに表示する",
  "Handle complex forms with dynamic fields (order items, tags)": "動的フィールド（注文アイテム、タグ）を持つ複雑なフォームを処理する",
  "Show conditional fields based on other form values": "他のフォーム値に基づいて条件付きフィールドを表示する",
  "Problems This Pattern Solves": "このパターンが解決する問題",
  "Problem": "問題",
  "Solution": "解決策",
  "Invalid data sent to API": "無効なデータがAPIに送信される",
  "Zod validates before submission": "Zodが送信前に検証する",
  "Type mismatch between form and API": "フォームとAPIの型が一致しない",
  "Infer TypeScript types from Zod schema": "ZodスキーマからTypeScript型を推論する",
  "Form re-renders on every keystroke": "キー入力ごとにフォームが再レンダリングされる",
  "React Hook Form uses uncontrolled inputs": "React Hook Formは非制御入力を使用する",
  "Hard to show validation errors": "バリデーションエラーを表示しにくい",
  "Automatic error state per field": "フィールドごとの自動エラー状態",
  "Dynamic fields are complex to manage": "動的フィールドの管理が複雑",
  "useFieldArray handles add/remove": "useFieldArrayが追加/削除を処理する",
  "Technology Stack": "技術スタック",
  "Library": "ライブラリ",
  "Purpose": "目的",
  "Form state management": "フォーム状態管理",
  "Schema validation": "スキーマバリデーション",
  "Zod integration": "Zod統合",
  "Form UI components": "フォームUIコンポーネント",
  "Installation": "インストール",
  "Form Component Architecture": "フォームコンポーネントアーキテクチャ",
  "The form system uses a layered component architecture:": "フォームシステムは階層化されたコンポーネントアーキテクチャを使用します：",
  "Component": "コンポーネント",
  "Role": "役割",
  "Context provider that wraps the entire form (uses FormProvider from react-hook-form)": "フォーム全体をラップするコンテキストプロバイダー（react-hook-formのFormProviderを使用）",
  "Connects a field to form state using Controller": "Controllerを使用してフィールドをフォーム状態に接続",
  "Container for a single form field (label, input, error)": "単一フォームフィールドのコンテナ（ラベル、入力、エラー）",
  "Label that auto-connects to the field and shows error state": "フィールドに自動接続し、エラー状態を表示するラベル",
  "Passes form field props to the input element": "フォームフィールドのpropsを入力要素に渡す",
  "Displays validation error message": "バリデーションエラーメッセージを表示",
  "Optional help text for the field": "フィールドのオプションヘルプテキスト",
  "Basic Form Structure": "基本的なフォーム構造",
  "Use Case: Product Create Form": "ユースケース: 製品作成フォーム",
  "Scenario: User needs to create a new product with code, name, price, and status.": "シナリオ: ユーザーがコード、名前、価格、ステータスを持つ新しい製品を作成する必要がある。",
  "Solution: Define schema with validation rules, use Form components for consistent error display.": "解決策: バリデーションルール付きのスキーマを定義し、一貫したエラー表示のためにFormコンポーネントを使用する。",
  "Zod Schema Definition": "Zodスキーマ定義",
  "Define validation rules that match your API requirements:": "API要件に合致するバリデーションルールを定義します：",
  "Update schema with optional fields and version": "オプションフィールドとバージョンを含む更新スキーマ",
  "Form Component": "フォームコンポーネント",
  "Connect the schema to React Hook Form using Form components:": "Formコンポーネントを使用してスキーマをReact Hook Formに接続します：",
  "Reusable Form Components": "再利用可能なフォームコンポーネント",
  "Use Case: Consistent Form Field Styling": "ユースケース: 一貫したフォームフィールドスタイリング",
  "Scenario: All form fields should have consistent label, error display, and required indicator.": "シナリオ: すべてのフォームフィールドは一貫したラベル、エラー表示、必須インジケーターを持つべき。",
  "Solution: Create a custom wrapper component that uses shadcn/ui Form components.": "解決策: shadcn/ui Formコンポーネントを使用するカスタムラッパーコンポーネントを作成する。",
  "Using CustomFormItem": "CustomFormItemの使用方法",
  "Input Component (Simple, No Error Prop)": "Inputコンポーネント（シンプル、error propなし）",
  "Note: The Input component does NOT have an error prop. Error display is handled by FormMessage.": "注意: Inputコンポーネントにはerrorプロパティがありません。エラー表示はFormMessageによって処理されます。",
  "Form Component Implementation": "フォームコンポーネント実装",
  "The Form components from shadcn/ui provide context-based error handling:": "shadcn/uiのFormコンポーネントはコンテキストベースのエラー処理を提供します：",
  "Form is just FormProvider re-exported": "FormはFormProviderを再エクスポートしたもの",
  "FormField wraps Controller and provides field context": "FormFieldはControllerをラップし、フィールドコンテキストを提供",
  "useFormField hook retrieves field state from context": "useFormFieldフックはコンテキストからフィールド状態を取得",
  "FormControl passes aria attributes for accessibility": "FormControlはアクセシビリティのためにaria属性を渡す",
  "FormMessage automatically displays error from context": "FormMessageはコンテキストからエラーを自動表示",
  "Advanced Form Patterns": "高度なフォームパターン",
  "Use Case: Order Form with Multiple Items": "ユースケース: 複数アイテムを持つ注文フォーム",
  "Scenario: User creates an order with multiple line items. Items can be added or removed.": "シナリオ: ユーザーが複数の明細を持つ注文を作成する。アイテムは追加・削除可能。",
  "Problem: Managing array of fields with validation is complex.": "問題: バリデーション付きのフィールド配列の管理が複雑。",
  "Solution: useFieldArray provides add, remove, and update methods with proper validation.": "解決策: useFieldArrayが適切なバリデーションと共に追加、削除、更新メソッドを提供する。",
  "Use Case: Payment Form with Conditional Fields": "ユースケース: 条件付きフィールドを持つ支払いフォーム",
  "Scenario: Form shows different fields based on payment method selection.": "シナリオ: フォームが支払い方法の選択に基づいて異なるフィールドを表示する。",
  "Problem: Need to watch a field value and conditionally render other fields.": "問題: フィールド値を監視し、条件に応じて他のフィールドをレンダリングする必要がある。",
  "Solution: useWatch subscribes to field changes without causing full form re-render.": "解決策: useWatchがフォーム全体の再レンダリングを起こさずにフィールド変更を監視する。",
  "Form with React Query": "React Query付きフォーム",
  "Use Case: Create Product with API Integration": "ユースケース: API統合による製品作成",
  "Scenario: Submit form data to API and handle success/error states.": "シナリオ: フォームデータをAPIに送信し、成功/エラー状態を処理する。",
  "Solution: Container component combines form with React Query mutation.": "解決策: コンテナコンポーネントがフォームとReact Queryミューテーションを組み合わせる。",
  "Use Case: Edit Product with Pre-populated Data": "ユースケース: 事前入力データによる製品編集",
  "Scenario: Load existing product data into form for editing.": "シナリオ: 編集のために既存の製品データをフォームに読み込む。",
  "Problem: Need to fetch data before rendering form with default values.": "問題: デフォルト値を持つフォームをレンダリングする前にデータを取得する必要がある。",
  "Solution: Container fetches data, passes to form as defaultValues.": "解決策: コンテナがデータを取得し、defaultValuesとしてフォームに渡す。",
  "Complex Validation Patterns": "複雑なバリデーションパターン",
  "Use Case: Date Range Validation": "ユースケース: 日付範囲バリデーション",
  "Scenario: End date must be after start date.": "シナリオ: 終了日は開始日より後でなければならない。",
  "Solution: Use Zod refine to validate across multiple fields.": "解決策: Zod refineを使用して複数フィールドにわたるバリデーションを行う。",
  "Use Case: Unique Code Validation": "ユースケース: 一意コードバリデーション",
  "Scenario: Product code must not already exist in database.": "シナリオ: 製品コードはデータベースに既に存在してはならない。",
  "Problem: Need to call API to check uniqueness.": "問題: 一意性を確認するためにAPIを呼び出す必要がある。",
  "Solution: Use async refine to validate against API.": "解決策: async refineを使用してAPIに対してバリデーションを行う。",
  "In the form": "フォーム内",
  "Validate on blur for async validation": "非同期バリデーションのためにonBlurで検証",
  "Best Practices": "ベストプラクティス",
  "1. Colocate Schemas with Forms": "1. スキーマをフォームと同じ場所に配置する",
  "Why: Keeps validation logic close to the form that uses it.": "理由: バリデーションロジックをそれを使用するフォームの近くに保つ。",
  "2. Use Mode Appropriately": "2. モードを適切に使用する",
  "Choose validation timing based on form complexity:": "フォームの複雑さに基づいてバリデーションのタイミングを選択します：",
  "Validate on submit (default) - best for simple forms": "送信時に検証（デフォルト） - シンプルなフォームに最適",
  "Validate on blur - best for forms with async validation": "フォーカスアウト時に検証 - 非同期バリデーションを持つフォームに最適",
  "Validate on change - best for real-time feedback": "変更時に検証 - リアルタイムフィードバックに最適",
  "3. Extract Common Schemas": "3. 共通スキーマを抽出する",
  "Why: Reuse validation rules across multiple forms.": "理由: 複数のフォームでバリデーションルールを再利用する。",
  "4. Handle Server Errors": "4. サーバーエラーを処理する",
  "Scenario: Server returns field-level validation errors.": "シナリオ: サーバーがフィールドレベルのバリデーションエラーを返す。",
  "Solution: Use setError to display server errors on specific fields.": "解決策: setErrorを使用してサーバーエラーを特定のフィールドに表示する。",
  "Set field-level errors from server": "サーバーからのフィールドレベルエラーを設定"
}
