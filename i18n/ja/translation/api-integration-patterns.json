{
  "Learn how to integrate with backend APIs using generated OpenAPI SDKs for type-safe API calls.": "生成されたOpenAPI SDKを使用して、型安全なAPIコールでバックエンドAPIと統合する方法を学びます。",
  "API Integration Patterns": "API統合パターン",
  "This guide explains how to connect frontend applications to MBC CQRS Serverless backends using auto-generated TypeScript SDKs. Type-safe API integration catches errors at compile time and provides excellent developer experience with autocomplete.": "このガイドでは、自動生成されたTypeScript SDKを使用してフロントエンドアプリケーションをMBC CQRS Serverlessバックエンドに接続する方法を説明します。型安全なAPI統合により、コンパイル時にエラーを検出し、オートコンプリートによる優れた開発者体験を提供します。",
  "When to Use This Guide": "このガイドを使用するタイミング",
  "Use this guide when you need to:": "以下の場合にこのガイドを使用してください：",
  "Connect a Next.js frontend to an MBC CQRS Serverless API": "Next.jsフロントエンドをMBC CQRS Serverless APIに接続する",
  "Generate TypeScript types from OpenAPI specification": "OpenAPI仕様からTypeScript型を生成する",
  "Add authentication headers automatically to API requests": "APIリクエストに認証ヘッダーを自動的に追加する",
  "Handle API errors consistently across the application": "アプリケーション全体で一貫したAPIエラー処理を行う",
  "Support multi-tenant API calls with tenant headers": "テナントヘッダーを使用したマルチテナントAPI呼び出しをサポートする",
  "Problems This Pattern Solves": "このパターンが解決する問題",
  "Problem": "問題",
  "Solution": "解決策",
  "Frontend types don't match backend API": "フロントエンドの型がバックエンドAPIと一致しない",
  "Generate SDK from OpenAPI spec - types always match": "OpenAPI仕様からSDKを生成 - 型が常に一致",
  "Forgetting to add auth token to requests": "リクエストに認証トークンを追加し忘れる",
  "Use interceptors to add headers automatically": "インターセプターを使用してヘッダーを自動的に追加",
  "Inconsistent error handling across components": "コンポーネント間でエラー処理が一貫していない",
  "Centralize error handling in API wrapper": "APIラッパーでエラー処理を一元化",
  "Tenant header missing in some requests": "一部のリクエストでテナントヘッダーが欠落",
  "Add tenant interceptor that reads from store": "ストアから読み取るテナントインターセプターを追加",
  "Hard to update when API changes": "API変更時の更新が困難",
  "Regenerate SDK with one command": "1つのコマンドでSDKを再生成",
  "SDK Generation Setup": "SDK生成のセットアップ",
  "Use Case: Generate Type-Safe API Client": "ユースケース：型安全なAPIクライアントの生成",
  "Scenario: Backend team updates the API, and you need frontend types to match.": "シナリオ：バックエンドチームがAPIを更新し、フロントエンドの型を一致させる必要がある。",
  "Solution: Generate SDK from OpenAPI specification file that backend exports.": "解決策：バックエンドがエクスポートするOpenAPI仕様ファイルからSDKを生成する。",
  "Installing Dependencies": "依存関係のインストール",
  "Configuration": "設定",
  "Package.json Scripts": "Package.jsonスクリプト",
  "Generated SDK Structure": "生成されるSDK構造",
  "After running `npm run generate-sdk`, the following files are created:": "`npm run generate-sdk`を実行すると、以下のファイルが作成されます：",
  "Generated Types Example": "生成される型の例",
  "These types are generated from your OpenAPI spec and match your backend exactly:": "これらの型はOpenAPI仕様から生成され、バックエンドと完全に一致します：",
  "Generated Services Example": "生成されるサービスの例",
  "Service classes provide typed methods for each API endpoint:": "サービスクラスは各APIエンドポイントに型付きメソッドを提供します：",
  "Client Configuration": "クライアント設定",
  "Use Case: Add Authentication to All Requests": "ユースケース：すべてのリクエストに認証を追加",
  "Scenario: Every API request needs a Bearer token from Cognito.": "シナリオ：すべてのAPIリクエストにCognitoからのBearerトークンが必要。",
  "Problem: Manually adding headers to each request is error-prone.": "問題：各リクエストに手動でヘッダーを追加するとエラーが発生しやすい。",
  "Solution: Use interceptors to add authentication header automatically.": "解決策：インターセプターを使用して認証ヘッダーを自動的に追加する。",
  "Use Case: Create API Wrapper with Error Handling": "ユースケース：エラーハンドリング付きAPIラッパーの作成",
  "Scenario: Components need clean APIs that throw meaningful errors.": "シナリオ：コンポーネントは意味のあるエラーをスローするクリーンなAPIが必要。",
  "Problem: Generated SDK returns `{ data, error }` which requires handling in every component.": "問題：生成されたSDKは`{ data, error }`を返すため、すべてのコンポーネントで処理が必要。",
  "Solution: Create wrapper functions that throw on errors for use with React Query.": "解決策：React Queryで使用するためにエラー時にスローするラッパー関数を作成する。",
  "React Query Integration": "React Query統合",
  "Use Case: Data Fetching with Caching": "ユースケース：キャッシュ付きデータフェッチ",
  "Scenario: Display product list and detail pages with efficient caching.": "シナリオ：効率的なキャッシュで製品リストと詳細ページを表示する。",
  "Solution: Create React Query hooks that use the API wrapper.": "解決策：APIラッパーを使用するReact Queryフックを作成する。",
  "Use Case: Product List with Filtering": "ユースケース：フィルタリング付き製品リスト",
  "Scenario: Display filterable, paginated product table.": "シナリオ：フィルタリング可能でページネーション付きの製品テーブルを表示する。",
  "Error Handling": "エラーハンドリング",
  "Use Case: Structured Error Responses": "ユースケース：構造化されたエラーレスポンス",
  "Scenario: Backend returns structured errors with field-level validation details.": "シナリオ：バックエンドがフィールドレベルのバリデーション詳細を含む構造化エラーを返す。",
  "Solution: Create error types that match backend response format.": "解決策：バックエンドのレスポンス形式と一致するエラー型を作成する。",
  "Use Case: Centralized Error Handler": "ユースケース：一元化されたエラーハンドラー",
  "Scenario: Convert various error types to consistent ApiException.": "シナリオ：様々なエラータイプを一貫したApiExceptionに変換する。",
  "Use Case: Display Errors with Field Details": "ユースケース：フィールド詳細付きエラー表示",
  "Scenario: Show validation errors returned by the server.": "シナリオ：サーバーから返されたバリデーションエラーを表示する。",
  "Multi-Tenant API Calls": "マルチテナントAPI呼び出し",
  "Use Case: Tenant Context for SaaS Applications": "ユースケース：SaaSアプリケーション用テナントコンテキスト",
  "Scenario: User can switch between tenants, and all API calls should use the selected tenant.": "シナリオ：ユーザーがテナント間を切り替え可能で、すべてのAPI呼び出しが選択されたテナントを使用する必要がある。",
  "Solution: Store tenant in context/store and add to API headers automatically.": "解決策：テナントをコンテキスト/ストアに保存し、APIヘッダーに自動的に追加する。",
  "Use Case: Tenant-Scoped Queries": "ユースケース：テナントスコープのクエリ",
  "Scenario: Product list should only show products for the current tenant.": "シナリオ：製品リストは現在のテナントの製品のみを表示する必要がある。",
  "File Upload Integration": "ファイルアップロード統合",
  "Use Case: Upload Files to S3 via API": "ユースケース：API経由でS3にファイルをアップロード",
  "Scenario: User uploads product images that need to be stored in S3.": "シナリオ：ユーザーがS3に保存する必要がある製品画像をアップロードする。",
  "Best Practices": "ベストプラクティス",
  "1. Always Regenerate SDK After Backend Changes": "1. バックエンド変更後は必ずSDKを再生成する",
  "When: Backend team deploys API changes.": "タイミング：バックエンドチームがAPI変更をデプロイした時。",
  "Why: Ensures frontend types match backend exactly.": "理由：フロントエンドの型がバックエンドと完全に一致することを保証する。",
  "2. Use Type Guards": "2. 型ガードを使用する",
  "When: Working with unknown data from external sources.": "タイミング：外部ソースからの不明なデータを扱う時。",
  "3. Handle Loading and Error States": "3. ローディングとエラー状態を処理する",
  "When: Displaying data from API queries.": "タイミング：APIクエリからデータを表示する時。",
  "4. Version Handling for Updates": "4. 更新時のバージョン処理",
  "When: Updating entities that use optimistic locking.": "タイミング：楽観的ロックを使用するエンティティを更新する時。",
  "Why: MBC CQRS Serverless uses version field to prevent concurrent update conflicts.": "理由：MBC CQRS Serverlessは同時更新の競合を防ぐためにversionフィールドを使用する。",
  "5. Retry Configuration": "5. リトライ設定",
  "When: Configuring React Query client.": "タイミング：React Queryクライアントを設定する時。",
  "Why: Avoid retrying client errors (4xx) that will always fail.": "理由：常に失敗するクライアントエラー(4xx)のリトライを避ける。"
}
