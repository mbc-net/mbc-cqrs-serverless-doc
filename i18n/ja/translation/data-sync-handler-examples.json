{
  "Practical examples of implementing Data Sync Handlers for various use cases.": "様々なユースケースにおけるData Sync Handlerの実装例。",
  "Data Sync Handler Examples": "Data Sync Handlerの実装例",
  "This guide explains how to implement Data Sync Handlers that automatically synchronize data from DynamoDB (command source) to RDS (query database). This is the core mechanism that enables the CQRS read model.": "このガイドでは、DynamoDB（コマンドソース）からRDS（クエリデータベース）にデータを自動的に同期するData Sync Handlerの実装方法を説明します。これはCQRS読み取りモデルを可能にする中核的なメカニズムです。",
  "When to Use This Guide": "このガイドを使用するタイミング",
  "Use this guide when you need to:": "以下の場合にこのガイドを使用してください：",
  "Sync entity data from DynamoDB to MySQL/PostgreSQL for complex queries": "複雑なクエリのためにエンティティデータをDynamoDBからMySQL/PostgreSQLに同期する",
  "Transform nested JSON attributes into relational columns": "ネストされたJSON属性をリレーショナルカラムに変換する",
  "Handle different record types within the same DynamoDB table": "同じDynamoDBテーブル内の異なるレコードタイプを処理する",
  "Process parent-child relationships (Order, OrderItem) separately": "親子関係（Order、OrderItem）を個別に処理する",
  "Problems This Pattern Solves": "このパターンが解決する問題",
  "Problem": "問題",
  "Solution": "解決策",
  "DynamoDB cannot do JOINs or complex filters": "DynamoDBはJOINや複雑なフィルターができない",
  "Sync data to RDS for SQL queries": "SQLクエリのためにデータをRDSに同期",
  "Version suffix in SK causes duplicate records": "SKのバージョンサフィックスが重複レコードを引き起こす",
  "Use removeSortKeyVersion() before upserting": "upsert前にremoveSortKeyVersion()を使用",
  "Different record types need different RDS tables": "異なるレコードタイプは異なるRDSテーブルが必要",
  "Filter by SK prefix in handler": "ハンドラーでSKプレフィックスによりフィルター",
  "JSON attributes need to be searchable columns": "JSON属性を検索可能なカラムにする必要がある",
  "Map attributes to individual RDS columns": "属性を個別のRDSカラムにマッピング",
  "Basic Structure": "基本構造",
  "All Data Sync Handlers follow this basic structure:": "すべてのData Sync Handlerは以下の基本構造に従います：",
  "Example 1: Simple Entity Sync": "例1: シンプルなエンティティ同期",
  "Use Case: Sync Products to Enable Search and Filtering": "ユースケース: 検索とフィルタリングを可能にする製品同期",
  "Scenario: Products stored in DynamoDB need to be searchable by category, price range, and text.": "シナリオ: DynamoDBに保存された製品をカテゴリ、価格帯、テキストで検索可能にする必要がある。",
  "Solution: Sync to RDS and map attributes to indexed columns for efficient queries.": "解決策: RDSに同期し、効率的なクエリのために属性をインデックス付きカラムにマッピングする。",
  "Example 2: Conditional Processing with SK Prefix": "例2: SKプレフィックスによる条件処理",
  "Use Case: Order and OrderItem in Same DynamoDB Table": "ユースケース: 同じDynamoDBテーブル内のOrderとOrderItem",
  "Scenario: Orders and their items share the same PK but have different SK prefixes. Each needs to go to a different RDS table.": "シナリオ: OrderとそのアイテムはPKを共有するがSKプレフィックスが異なる。それぞれ異なるRDSテーブルに保存する必要がある。",
  "Solution: Check SK prefix to route to appropriate sync logic.": "解決策: SKプレフィックスをチェックして適切な同期ロジックにルーティングする。",
  "Example 3: Complex Attribute Transformation": "例3: 複雑な属性変換",
  "Use Case: Notifications with Different Content Types": "ユースケース: 異なるコンテンツタイプを持つ通知",
  "Scenario: Notification entity has different content structures based on type (Alert, Info, Promotion).": "シナリオ: 通知エンティティはタイプ（Alert、Info、Promotion）に基づいて異なるコンテンツ構造を持つ。",
  "Solution: Extract and flatten type-specific fields into common RDS columns.": "解決策: タイプ固有のフィールドを抽出し、共通のRDSカラムにフラット化する。",
  "Example 4: PK Prefix Filtering": "例4: PKプレフィックスフィルタリング",
  "Use Case: User Records in Shared Table": "ユースケース: 共有テーブル内のユーザーレコード",
  "Scenario: Multiple entity types share a DynamoDB table. Handler should only process USER records.": "シナリオ: 複数のエンティティタイプがDynamoDBテーブルを共有。ハンドラーはUSERレコードのみを処理する必要がある。",
  "Solution: Check PK prefix and skip non-matching records early.": "解決策: PKプレフィックスをチェックし、一致しないレコードを早期にスキップする。",
  "Example 5: Parsing SK for Derived Data": "例5: SKからのデータ抽出",
  "Use Case: Master Data with Category Information in SK": "ユースケース: SKにカテゴリ情報を持つマスターデータ",
  "Scenario: SK contains structured data like \"SETTING#category#code\" that should be stored as separate columns.": "シナリオ: SKには\"SETTING#category#code\"のような構造化データが含まれ、個別のカラムとして保存する必要がある。",
  "Solution: Parse SK to extract type, category, and code for querying.": "解決策: SKを解析してタイプ、カテゴリ、コードを抽出してクエリに使用する。",
  "Registering Multiple Handlers": "複数ハンドラーの登録",
  "You can register multiple handlers for the same table to handle different record types:": "異なるレコードタイプを処理するために、同じテーブルに複数のハンドラーを登録できます：",
  "Best Practices": "ベストプラクティス",
  "1. Always Remove Version from SK": "1. SKからバージョンを必ず削除する",
  "Use `removeSortKeyVersion()` to get a consistent SK for RDS storage:": "`removeSortKeyVersion()`を使用してRDSストレージ用の一貫したSKを取得します：",
  "2. Handle undefined isDeleted": "2. undefined isDeletedを処理する",
  "Always provide a default value for `isDeleted`:": "`isDeleted`には常にデフォルト値を提供します：",
  "3. Store Both Original and Cleaned Keys": "3. オリジナルとクリーンなキーの両方を保存する",
  "Store original keys (cpk, csk) in create operations for reference:": "create操作で参照用にオリジナルキー（cpk, csk）を保存します：",
  "4. Type Your Attributes": "4. 属性に型を定義する",
  "Define interfaces for attributes to ensure type safety:": "型安全性を確保するために属性にインターフェースを定義します：",
  "5. Handle Null/Undefined Gracefully": "5. Null/Undefinedを適切に処理する",
  "Use nullish coalescing and optional chaining:": "nullish coalescing演算子とオプショナルチェーンを使用します："
}
