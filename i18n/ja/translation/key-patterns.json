{
  "Learn about partition key (PK) and sort key (SK) design patterns for DynamoDB.": "DynamoDBのパーティションキー（PK）とソートキー（SK）の設計パターンについて学びます。",
  "Key Design Patterns": "キー設計パターン",
  "This guide explains how to design partition keys (PK) and sort keys (SK) for your entities in DynamoDB. Proper key design is critical for performance, scalability, and query efficiency.": "このガイドでは、DynamoDBにおけるエンティティのパーティションキー（PK）とソートキー（SK）の設計方法を説明します。適切なキー設計は、パフォーマンス、スケーラビリティ、クエリ効率にとって重要です。",
  "When to Use This Guide": "このガイドを使用するタイミング",
  "Use this guide when you need to:": "以下が必要な場合にこのガイドを使用してください：",
  "Design keys for a new entity type": "新しいエンティティタイプのキーを設計する",
  "Model parent-child relationships (Order → OrderItems)": "親子関係をモデル化する（Order → OrderItems）",
  "Support multi-tenant data isolation": "マルチテナントデータ分離をサポートする",
  "Enable efficient query patterns (list by tenant, filter by date)": "効率的なクエリパターンを有効にする（テナント別リスト、日付フィルター）",
  "Handle versioning for optimistic locking": "楽観的ロック用のバージョニングを処理する",
  "Problems This Pattern Solves": "このパターンが解決する問題",
  "Problem": "問題",
  "Solution": "解決策",
  "Querying all items for a tenant is slow": "テナントの全アイテムをクエリするのが遅い",
  "Include tenant code in PK for partition-level isolation": "パーティションレベルの分離のためにPKにテナントコードを含める",
  "Can't list child items without knowing all keys": "すべてのキーを知らないと子アイテムをリストできない",
  "Use shared PK with different SK prefixes": "異なるSKプレフィックスで共有PKを使用する",
  "IDs are not sortable by creation time": "IDが作成時間でソートできない",
  "Use ULID which is both unique and time-sortable": "一意性と時間ソートの両方を持つULIDを使用する",
  "Version conflicts in concurrent updates": "同時更新でバージョン競合が発生する",
  "Version suffix in SK enables optimistic locking": "SKのバージョンサフィックスで楽観的ロックを有効にする",
  "Key Structure Overview": "キー構造の概要",
  "The framework uses a consistent key structure:": "フレームワークは一貫したキー構造を使用します：",
  "The `KEY_SEPARATOR` constant (`#`) is used to separate key components.": "`KEY_SEPARATOR`定数（`#`）はキーコンポーネントを区切るために使用されます。",
  "Basic Key Generation": "基本的なキー生成",
  "Import utilities from the core package:": "コアパッケージからユーティリティをインポートします：",
  "Generating Keys": "キーの生成",
  "Version Handling": "バージョン管理",
  "Common Key Patterns": "一般的なキーパターン",
  "Pattern 1: Simple Entity": "パターン1: シンプルなエンティティ",
  "Use Case: Product Catalog": "ユースケース: 商品カタログ",
  "Scenario: Store products that belong to a tenant with unique IDs.": "シナリオ: テナントに属する商品を一意のIDで保存します。",
  "When to use: Standalone entities without parent-child relationships.": "使用タイミング: 親子関係のないスタンドアロンエンティティ。",
  "Pattern 2: Hierarchical Entity": "パターン2: 階層エンティティ",
  "Use Case: Order with Line Items": "ユースケース: 明細付き注文",
  "Scenario: An order contains multiple items. Need to query all items for an order efficiently.": "シナリオ: 注文には複数のアイテムが含まれます。注文のすべてのアイテムを効率的にクエリする必要があります。",
  "Solution: Share PK between parent and children, use SK prefix to distinguish item types.": "解決策: 親と子の間でPKを共有し、SKプレフィックスでアイテムタイプを区別します。",
  "Pattern 3: User with Multiple Auth Providers": "パターン3: 複数認証プロバイダーを持つユーザー",
  "Use Case: Unified User Identity": "ユースケース: 統合ユーザーアイデンティティ",
  "Scenario: Users can sign in with local password, SSO, or OAuth. Need to link all auth methods to one user.": "シナリオ: ユーザーはローカルパスワード、SSO、またはOAuthでサインインできます。すべての認証方法を1人のユーザーにリンクする必要があります。",
  "Solution: Same PK for all user records, SK prefix indicates authentication provider.": "解決策: すべてのユーザーレコードに同じPKを使用し、SKプレフィックスで認証プロバイダーを示します。",
  "Pattern 4: Multi-Tenant Association": "パターン4: マルチテナント関連付け",
  "Use Case: User Belongs to Multiple Organizations": "ユースケース: ユーザーが複数の組織に所属",
  "Scenario: In a SaaS application, one user can belong to multiple tenants/organizations.": "シナリオ: SaaSアプリケーションでは、1人のユーザーが複数のテナント/組織に所属できます。",
  "Solution: Use a common tenant with SK that combines tenant and user codes.": "解決策: テナントコードとユーザーコードを組み合わせたSKを持つ共通テナントを使用します。",
  "Pattern 5: Master Data with Categories": "パターン5: カテゴリ付きマスターデータ",
  "Use Case: Application Settings and Configuration": "ユースケース: アプリケーション設定と構成",
  "Scenario: Store email templates, product categories, and application settings.": "シナリオ: メールテンプレート、商品カテゴリ、アプリケーション設定を保存します。",
  "Solution: Use type prefix (SETTING, DATA) in SK to organize different configuration types.": "解決策: SKにタイププレフィックス（SETTING、DATA）を使用して、異なる設定タイプを整理します。",
  "Pattern 6: Time-Series Data": "パターン6: 時系列データ",
  "Use Case: Activity Logs and Audit Trail": "ユースケース: アクティビティログと監査証跡",
  "Scenario: Store time-stamped events that need to be queried by date range.": "シナリオ: 日付範囲でクエリする必要があるタイムスタンプ付きイベントを保存します。",
  "Solution: Include date in PK for time-based partitioning, timestamp in SK for sorting.": "解決策: 時間ベースのパーティショニングのためにPKに日付を含め、ソートのためにSKにタイムスタンプを含めます。",
  "Key Helper Functions": "キーヘルパー関数",
  "Create a helpers file for consistent key generation:": "一貫したキー生成のためのヘルパーファイルを作成します：",
  "Version Management": "バージョン管理",
  "The framework uses versioning for optimistic locking:": "フレームワークは楽観的ロックのためにバージョニングを使用します：",
  "Query Patterns": "クエリパターン",
  "Query by PK": "PKによるクエリ",
  "Query with SK Prefix": "SKプレフィックスによるクエリ",
  "Query with SK Range": "SK範囲によるクエリ",
  "Best Practices": "ベストプラクティス",
  "1. Use Consistent Prefixes": "1. 一貫したプレフィックスを使用する",
  "Define prefixes as constants:": "プレフィックスを定数として定義します：",
  "2. Use ULID for Sortable IDs": "2. ソート可能なIDにはULIDを使用する",
  "ULID provides both uniqueness and time-based sorting:": "ULIDは一意性と時間ベースのソートの両方を提供します：",
  "3. Design for Query Patterns": "3. クエリパターンに合わせた設計",
  "Structure keys based on how you'll query data:": "データのクエリ方法に基づいてキーを構造化します：",
  "4. Keep PK Cardinality Manageable": "4. PKのカーディナリティを管理可能に保つ",
  "Avoid too many unique PKs to prevent hot partitions:": "ホットパーティションを防ぐために、ユニークなPKが多すぎないようにします：",
  "5. Include Tenant in PK": "5. PKにテナントを含める",
  "Always include tenant code in PK for multi-tenant isolation:": "マルチテナント分離のために、常にPKにテナントコードを含めます：",
  "6. Use Common Tenant for Shared Data": "6. 共有データには共通テナントを使用する",
  "Use a common tenant code for data shared across tenants:": "テナント間で共有されるデータには共通テナントコードを使用します：",
  "Anti-Patterns to Avoid": "避けるべきアンチパターン",
  "1. Embedding Too Much in Keys": "1. キーに情報を詰め込みすぎる",
  "2. Using Mutable Data in Keys": "2. キーに可変データを使用する",
  "3. Inconsistent Separators": "3. 一貫性のないセパレーター"
}