{
  "Learn about partition key (PK) and sort key (SK) design patterns for DynamoDB.": "DynamoDBのパーティションキー（PK）とソートキー（SK）の設計パターンについて学びます。",
  "Key Design Patterns": "キー設計パターン",
  "This guide explains how to design partition keys (PK) and sort keys (SK) for your entities in DynamoDB. Proper key design is critical for performance, scalability, and query efficiency.": "",
  "When to Use This Guide": "",
  "Use this guide when you need to:": "",
  "Design keys for a new entity type": "",
  "Model parent-child relationships (Order → OrderItems)": "",
  "Support multi-tenant data isolation": "",
  "Enable efficient query patterns (list by tenant, filter by date)": "",
  "Handle versioning for optimistic locking": "",
  "Problems This Pattern Solves": "",
  "Problem": "",
  "Solution": "",
  "Querying all items for a tenant is slow": "",
  "Include tenant code in PK for partition-level isolation": "",
  "Can't list child items without knowing all keys": "",
  "Use shared PK with different SK prefixes": "",
  "IDs are not sortable by creation time": "",
  "Use ULID which is both unique and time-sortable": "",
  "Version conflicts in concurrent updates": "",
  "Version suffix in SK enables optimistic locking": "",
  "Key Structure Overview": "キー構造の概要",
  "The framework uses a consistent key structure:": "フレームワークは一貫したキー構造を使用します：",
  "The `KEY_SEPARATOR` constant (`#`) is used to separate key components.": "`KEY_SEPARATOR`定数（`#`）はキーコンポーネントを区切るために使用されます。",
  "Basic Key Generation": "基本的なキー生成",
  "Import utilities from the core package:": "コアパッケージからユーティリティをインポートします：",
  "Generating Keys": "キーの生成",
  "Version Handling": "バージョン管理",
  "Common Key Patterns": "一般的なキーパターン",
  "Pattern 1: Simple Entity": "パターン1: シンプルなエンティティ",
  "Use Case: Product Catalog": "",
  "Scenario: Store products that belong to a tenant with unique IDs.": "",
  "When to use: Standalone entities without parent-child relationships.": "",
  "Pattern 2: Hierarchical Entity": "パターン2: 階層エンティティ",
  "Use Case: Order with Line Items": "",
  "Scenario: An order contains multiple items. Need to query all items for an order efficiently.": "",
  "Solution: Share PK between parent and children, use SK prefix to distinguish item types.": "",
  "Pattern 3: User with Multiple Auth Providers": "パターン3: 複数認証プロバイダーを持つユーザー",
  "Use Case: Unified User Identity": "",
  "Scenario: Users can sign in with local password, SSO, or OAuth. Need to link all auth methods to one user.": "",
  "Solution: Same PK for all user records, SK prefix indicates authentication provider.": "",
  "Pattern 4: Multi-Tenant Association": "パターン4: マルチテナント関連付け",
  "Use Case: User Belongs to Multiple Organizations": "",
  "Scenario: In a SaaS application, one user can belong to multiple tenants/organizations.": "",
  "Solution: Use a common tenant with SK that combines tenant and user codes.": "",
  "Pattern 5: Master Data with Categories": "パターン5: カテゴリ付きマスターデータ",
  "Use Case: Application Settings and Configuration": "",
  "Scenario: Store email templates, product categories, and application settings.": "",
  "Solution: Use type prefix (SETTING, DATA) in SK to organize different configuration types.": "",
  "Pattern 6: Time-Series Data": "パターン6: 時系列データ",
  "Use Case: Activity Logs and Audit Trail": "",
  "Scenario: Store time-stamped events that need to be queried by date range.": "",
  "Solution: Include date in PK for time-based partitioning, timestamp in SK for sorting.": "",
  "Key Helper Functions": "キーヘルパー関数",
  "Create a helpers file for consistent key generation:": "一貫したキー生成のためのヘルパーファイルを作成します：",
  "Version Management": "バージョン管理",
  "The framework uses versioning for optimistic locking:": "フレームワークは楽観的ロックのためにバージョニングを使用します：",
  "Query Patterns": "クエリパターン",
  "Query by PK": "PKによるクエリ",
  "Query with SK Prefix": "SKプレフィックスによるクエリ",
  "Query with SK Range": "SK範囲によるクエリ",
  "Best Practices": "ベストプラクティス",
  "1. Use Consistent Prefixes": "1. 一貫したプレフィックスを使用する",
  "Define prefixes as constants:": "プレフィックスを定数として定義します：",
  "2. Use ULID for Sortable IDs": "2. ソート可能なIDにはULIDを使用する",
  "ULID provides both uniqueness and time-based sorting:": "ULIDは一意性と時間ベースのソートの両方を提供します：",
  "3. Design for Query Patterns": "3. クエリパターンに合わせた設計",
  "Structure keys based on how you'll query data:": "データのクエリ方法に基づいてキーを構造化します：",
  "4. Keep PK Cardinality Manageable": "4. PKのカーディナリティを管理可能に保つ",
  "Avoid too many unique PKs to prevent hot partitions:": "ホットパーティションを防ぐために、ユニークなPKが多すぎないようにします：",
  "5. Include Tenant in PK": "5. PKにテナントを含める",
  "Always include tenant code in PK for multi-tenant isolation:": "マルチテナント分離のために、常にPKにテナントコードを含めます：",
  "6. Use Common Tenant for Shared Data": "6. 共有データには共通テナントを使用する",
  "Use a common tenant code for data shared across tenants:": "テナント間で共有されるデータには共通テナントコードを使用します：",
  "Anti-Patterns to Avoid": "避けるべきアンチパターン",
  "1. Embedding Too Much in Keys": "1. キーに情報を詰め込みすぎる",
  "2. Using Mutable Data in Keys": "2. キーに可変データを使用する",
  "3. Inconsistent Separators": "3. 一貫性のないセパレーター"
}